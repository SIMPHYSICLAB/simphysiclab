# -*- coding: utf-8 -*-
"""330. Comportamiento de sistemas.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-P_gW3vjEdb_g1ZNFVqMyuYdqw0EBwn3

# <font color="darkorange">330. Comportamiento de sistemas</font>

**Autoría**:

*   Eduardo Iáñez (eianez@umh.es)
*   Vicente Quiles (vquiles@umh.es)
*   Federico Botella (federico@umh.es)

Departamento de Ingeniería de Sistemas y Automática.

Universidad Miguel Hernández de Elche.


**Financiación**: El material que aparece a continuación se ha desarrollado dentro del marco del proyecto UNIDIGITAL- SIMPHYSICLAB.

<small><img src=https://raw.githubusercontent.com/SIMPHYSICLAB/simphysiclab/main/images/logo_unidigital_simphysiclab.png></small>

**Fecha última edición**: 30/09/2022

**Licencia**: <small><a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" /></a><br /></small>

*No olvides hacer una copia si deseas utilizarlo. Al usar estos contenidos, aceptas nuestros términos de uso y nuestra política de privacidad.*

https://www.youtube.com/watch?v=-C4Hh98Gre0&ab_channel=UniversidadMiguelHern%C3%A1ndezdeElche

Video utilizado para el texto

### <font color="darkorange">Configuración del cuaderno</font>

Para garantizar la funcionalidad completa de este cuaderno, es preciso ejecutar la siguiente celda de código. Se instalarán las librerías necesarias de Python y se importarán los módulos necesarios, y se cargarán de GitHub las librerías desarrolladas.
"""

# Commented out IPython magic to ensure Python compatibility.
#@title <font color="steelblue" size="+1"> Ejecutar configuración { display-mode: "form" }
print("Iniciando configuración:")
print("- Instalando módulos de Python control, ipympl y tbcontrol ...")
#Instalacion dependencias
!pip install control==0.9.3.post2 -q
!pip install ipympl==0.9.3 -q
!pip install tbcontrol==0.2.1 -q
print("  - Modulos instalados!")

#Clonar github con los repositorios
print("- Importando módulos específicos de github de sistemas, ldr y pid ...")
!wget {f"https://raw.githubusercontent.com/SIMPHYSICLAB/simphysiclab/main/libraries/simphysiclab_sistemas.py"} -q
!wget {f"https://raw.githubusercontent.com/SIMPHYSICLAB/simphysiclab/main/libraries/simphysiclab_ldr.py"} -q
!wget {f"https://raw.githubusercontent.com/SIMPHYSICLAB/simphysiclab/main/libraries/simphysiclab_pid.py"} -q
import simphysiclab_sistemas as SIS
import simphysiclab_ldr as LDR
import simphysiclab_pid as PID
print("  - Módulos importadas!")

print("- Importando librerias de Python ...")
#Standard Python libraries:
import math
import random
import time
import copy
import numpy as np

#Specific control system python libraries:
import control
import sympy
from tbcontrol.symbolic import routh

#Plot python libraries interactive
# %matplotlib ipympl
sympy.init_printing()
import matplotlib.pyplot as plt
import matplotlib.path as mpath

from google.colab import output
output.enable_custom_widget_manager()
import ipywidgets as widgets

print("  - Librerias importadas!\n")
print("Cuarderno configurado.")

"""### <font color="darkorange">Introducción</font>

### <font color="darkorange">Objetivos</font>

### <font color="darkorange">Contenidos</font>
1.   Conceptos
2.   Respuesta ejemplo
3.   Modo transitorio
4.   Efecto de los parámetros con un polo real
5.   Polos dominantes
6.   Efecto de los parámetros con polos complejos conjugados

### <font color="darkorange">Funciones utilizadas en este cuaderno</font>
A continuación, se incluye un listado de las funciones incluidas en las librerías de GitHub desarrolladas en el proyecto UNIDIGITAL-SIMPHYSICILAB y que se utilizarán en este cuaderno. El código de aquellas funciones que sean utilizadas por primera vez será incluido además en el apartado correspondiente para poder analizarlo.

*   1
*   2

## <font color="darkorange">1. Conceptos</font>

Sobre los sistemas se pueden realizar varios tipos de analis:
Análisis temporal: Someter al sistema a diferentes entradas de prueba, observar la respuesta del sistema en el tiempo.
Análisis frecuencia: Someter al sistema a entradas senoidales, obervar la evolución de la salida en función de la frecuencia de la señal de entrada.

En este tema analizaremos la respuesta temporal ante diferentes entradas. Este analisis se puede realizar para sistemas de orden: primer, segundo o superior.

El análisis temporal consiste en excitar el sistema con señales de entrada normalizadas y estudiar la evolución de la salida en el tiempo.
Las señales habituales y sus transformadas de Laplace son:

Impulso:

$$\begin{equation}
Δ(s)=1
\end{equation}$$

Señal que toma un valor muy alto en t=0 y luego desaparece. Es una señal que físicamente no se puede realizar. Se puede modelar como un impulso de altura y duración determinados.

Util para estudiar respuesta del sistema ante entrada de choque.

Escalón unitario:

$$\begin{equation}
U(s)=1/s
\end{equation}$$
"""

fig = plt.figure(figsize = (10,5))
ax = fig.add_subplot(1,2,1)
stepTF=SIS.generarTF("num_den",[1],[1,0],1)
invStepTF,t=SIS.inversaLaplace(stepTF,1)
valuesSystemStepTF = [invStepTF.subs(t, val) for val in np.arange(0.0, 21.0, 0.1)]
ax.plot(np.arange(0.0, 21.0, 0.1), valuesSystemStepTF)

"""Útil para estudiar como cambia el sistema ante cambios bruscos.

Rampa unitaria:

$$\begin{equation}
R(s)=1/s^2
\end{equation}$$
"""

fig = plt.figure(figsize = (10,5))
ax = fig.add_subplot(1,2,1)
rampaUnitTF=SIS.generarTF("num_den",[1],[1,0,0],1)
invRampaUnitTF,t=SIS.inversaLaplace(rampaUnitTF,1)
valuesSystemUnitTF = [invRampaUnitTF.subs(t, val) for val in np.arange(0.0, 21.0, 0.1)]
ax.plot(np.arange(0.0, 21.0, 0.1), valuesSystemUnitTF)

"""Útil para estudiar como cambia el sistema ante cambios graduales.

## <font color="darkorange">2. Respuesta ejemplo</font>

Para analizar la respuesta del sistema, primero vamos a analizar la forma del sistema individualmente, la forma de la entrada del sistema y la respuesta del sistema ante dicha entrada:
"""

t = sympy.Symbol('t', positive=True)
a = sympy.symbols('a')
TF=SIS.generarTF("num_den",[1],[1,1],1)

TF

fig = plt.figure(figsize = (10,5))
ax = fig.add_subplot(1,2,1)
solvea,t=SIS.inversaLaplace(TF,1)
valuesSystem = [solvea.subs(t, val) for val in np.arange(0.0, 21.0, 0.1)]
ax.plot(np.arange(0.0, 21.0, 0.1), valuesSystem)

"""Definimos una entrada tipo escalón, la más común para el análisis de sistemas."""

stepTF

axz=SIS.zoom(ax,[[0,20],[0,2]])
axz.plot(np.arange(0.0, 21.0, 0.1), valuesSystemStepTF,color="g")

"""Multiplicamos el sistema por la entrada tipo escalón y se calcula la evolución temporal de la respuesta del sistema ante dicha entrada."""

axz=SIS.zoom(axz,[[0,20],[0,2]])
solvea,t=SIS.inversaLaplace(TF*stepTF,1)
valuesSystem = [solvea.subs(t, val) for val in np.arange(0.0, 21.0, 0.1)]
axz.plot(np.arange(0.0, 21.0, 0.1), valuesSystem,color="r")

"""Esta respuesta también se puede calcular con la función predefinida:"""

fig = plt.figure(figsize = (10,5))
ax2 = fig.add_subplot(1,2,1)
y,t=SIS.respuestaEscalon(ax2,TF,20)

"""La respuesta del sistema como se puede observar tiene una parte cambiante y una parte en equilibrio que tiende a un valor determinado del eje Y, este valor se denomina el valor final y es al que tiende el sistema cuando se estabiliza. El regimen de estabilización se denomina regimen Permanente y el regimen que antecede a este se denomina regimen Transitorio, de esta forma la salida se puede definir como:

$$\begin{equation}
y(t)=y_T (t)+y_p (t)\\
Salida = Transitorio + permanente
\end{equation}$$

Se definirá el tramo de Régimen transitorio como el intervalo entre 0 y el 5% del valor vinal de la señal.También se define el Régimen permanente como el tramo comprendido entre el 5% del valor final y el todo el continuo de la señal. El tiempo que el sistema sistema tarda en alcanzar el régimen permanente se denomina tiempo de establecimiento y su nomenclatura es:$$T_s$$ Este parámetro se puede calcular sobre la gráfica (95% del valor final) o a partir de la ecuación del sistema en el dominio de Laplace: Y(t)-0.95
"""

ax2=SIS.zoom(ax2,[[0,20],[0,1.1]])
SIS.parametrosTipoRegimen(ax2,y,t)
Video=SIS.parametrosTipoRegimenVideo(y,t)

Video

"""## <font color="darkorange">3. Modo transitorio</font>

$$\begin{equation}
Sistema~genérico:~~G(s)=\frac{N(s)}{D(s)}
\end{equation}$$

$$\begin{equation}
Respuesta~ante~escalón:~~Y(s)=\frac{1}{s}*G(s)=\frac{N(s)}{s*D(s)}
\end{equation}$$


$$\begin{equation}
y(t)=\mathcal{L}^{-1}[Y(s)]=\mathcal{L}^{-1}[\frac{N(s)}{s*D(s)}]=\mathcal{L}^{-1}[\frac{N(s)}{s*(s-a_1)*(s-a_2)*...*(s-a_n)}]
\end{equation}$$
Donde $$s=a_1,a_2,...,a_n $$ Son los polos del sistema.


$$\begin{equation}
y(t)=\mathcal{L}^{-1}[Y(s)]=\mathcal{L}^{-1}[\frac{A_0}{s}+\frac{A_1}{(s-a_1)}+\frac{A_2}{(s-a_2)}+...+\frac{A_n}{(s-a_n)}]
\end{equation}$$

Al transformar al dominio de Laplace podemos analizar la respuesta temporal de cada parte, pues ya la hemos analizado y sabemos los regimenes de operación:


$$\begin{equation}
y(t)= 0~~~~~~~~~~~~~~~~~~~~~~~t<0
\end{equation}$$
$$\begin{equation}
y(t)= A_0~+~A_1 e^{a_1 t}~+~A_2 e^{a_2 t}~+...+~A_n e^{a_n t}~~t>=0
\end{equation}$$




La siguiente parte del sistema $$A_1 e^{a_1 t}~+~A_2 e^{a_2 t}~+...+~A_n e^{a_n t}$$ ha sido analizada previamente y se sabe que cuando el sistema es estable, según t aumenta este valor tiende a cero y por lo tanto todo este termino tenderá a 0 con el tiempo. La suma de los diferentes polos conforman por lo tanto el régimen transitorio. El tipo de transitorio depende del tipo de polo: Real o Complejo conjugado. Esto será analizado más a delante.

Por lo tanto la parte que no disminuye con el valor temporal $$ A_0 $$ es el régimen permanente.

## <font color="darkorange">4. Efecto de los parámetros con un polo real</font>

A continuación analizamos como afecta la posición del polo real a la respuesta del sistema.
"""

a1=SIS.generarTF("ceros_polos",[],[-1])
a2=SIS.generarTF("ceros_polos",[],[-5])
a3=SIS.generarTF("ceros_polos",[],[-15])

fig = plt.figure(figsize = (10,5))
ax1 = fig.add_subplot(1,2,1)
SIS.dibujarEjes(ax1,5,[[-20,5],[-5,5]])
SIS.dibujarPolosCeros(ax1,[[-20,5],[-5,5]],a1,1)
ax1.annotate('a1',(-1,-3),(-1,-3),c='g')

SIS.dibujarPolosCeros(ax1,[[-20,5],[-5,5]],a2,0.8)
ax1.annotate('a2',(-5,-3),(-5,-3),c='y')

SIS.dibujarPolosCeros(ax1,[[-20,5],[-5,5]],a3,0.6)
ax1.annotate('a3',(-15,-3),(-15,-3),c='b')

fig = plt.figure(figsize = (10,5))
cx = fig.add_subplot(1,2,1)

solvep,t=SIS.inversaLaplace(a1,1)
valuesSystem = [solvep.subs(t, val) for val in np.arange(0.0, 21.0, 0.1)]
cx.plot(np.arange(0.0, 21.0, 0.1), valuesSystem,'g')
cx.annotate('a1',(3,0.15),(3,0.15),c='g')

solvep,t=SIS.inversaLaplace(a2,1)
valuesSystem = [solvep.subs(t, val) for val in np.arange(0.0, 21.0, 0.1)]
cx.plot(np.arange(0.0, 21.0, 0.1), valuesSystem,'y')
cx.annotate('a2',(1.5,0.05),(1.5,0.05),c='y')

solvep,t=SIS.inversaLaplace(a3,1)
valuesSystem = [solvep.subs(t, val) for val in np.arange(0.0, 21.0, 0.1)]
cx.plot(np.arange(0.0, 21.0, 0.1), valuesSystem,'b')
cx.annotate('a1',(0.2,0.01),(0.2,0.01),c='b')

"""Se puede observar que si el polo es más cercano al eje imaginario, su contribución al regimen permanente es más notoria y por tanto se considera más dominante para el sistema.

## <font color="darkorange">5. Polos dominantes</font>

Se considera el polo dominante al más cerncano al eje imaginario, la distancia de este al eje Imaginario se determina como D. El efecto de los polos dominantes perdura más en el tiempo. ¿Que polos no se consideran dominantes para el sistema?

-Un polo cerca de un cero se considera irrelevante si la distancia es menor que $D/6$.

-Un polo se considera irrelevante si esta a una distancia del eje Imaginario mayor que $6D$.
"""

G=5*SIS.generarTF("ceros_polos",[-4],[-1, -4, -3,-15])

[ceros,polos,ganancia]=SIS.InfoTF("ceros_polos",G)

for p in polos:
  print("polos: ",p,SIS.polosDominantes(G,p))

"""Según la función si el polo devuelve un valor False, es despreciable para su contribución al sistema.

## <font color="darkorange">6. Efecto de los parámetros con polos complejos conjugados</font>
"""

a = sympy.symbols('a')
b = sympy.symbols('b')
TF=SIS.generarTF("ceros_polos",[],[-a+b*1j,-a-b*1j],1)

TF

"""Modificando el parametro "a", se modifica la velocidad de amortiguamiento, al igual que en el caso anterior, los polos dominantes tendrán más contribución de transitorio y taradará más en amortiguarse su respuesta."""

fig = plt.figure(figsize = (10,5))
ax1 = fig.add_subplot(1,2,1)

fixATF=TF.subs(b,3)

SIS.dibujarEjes(ax1,5,[[-25,5],[-10,5]])
SIS.dibujarPolosCeros(ax1,[[-20,5],[-10,5]],fixATF.subs(a,1),1)
ax1.annotate('a1',(-1,-5),(-1,-5),c='g')

SIS.dibujarPolosCeros(ax1,[[-25,5],[-5,5]],fixATF.subs(a,5),0.8)
ax1.annotate('a2',(-5,-5),(-5,-5),c='y')

SIS.dibujarPolosCeros(ax1,[[-25,5],[-5,5]],fixATF.subs(a,15),0.6)
ax1.annotate('a3',(-15,-5),(-15,-5),c='b')

fig = plt.figure(figsize = (10,5))
cx = fig.add_subplot(1,2,1)

solvep,t=SIS.inversaLaplace(fixATF.subs(a,1),1)
valuesSystem = [solvep.subs(t, val) for val in np.arange(0.0, 10.0, 0.1)]
cx.plot(np.arange(0.0, 10.0, 0.1), valuesSystem,'g')
cx.annotate('a1',(1.2,0.15),(1.2,0.15),c='g')

solvep,t=SIS.inversaLaplace(fixATF.subs(a,5),1)
valuesSystem = [solvep.subs(t, val) for val in np.arange(0.0, 10.0, 0.1)]
cx.plot(np.arange(0.0, 10.0, 0.1), valuesSystem,'y')
cx.annotate('a2',(0.4,0.05),(0.4,0.05),c='y')

solvep,t=SIS.inversaLaplace(fixATF.subs(a,15),1)
valuesSystem = [solvep.subs(t, val) for val in np.arange(0.0, 10.0, 0.1)]
cx.plot(np.arange(0.0, 10.0, 0.1), valuesSystem,'b')
cx.annotate('a3',(0.2,0.01),(0.2,0.01),c='b')

"""Modificando el parametro "b", se modifica la frecuencia de oscilación. El amortiguamiento será igual pero la velocidad de frecuencia varía. Cuanto más cercano al eje real, la frecuencia será más baja, cuanto más alejado, la frecuencia será más alta."""

fig = plt.figure(figsize = (10,5))
ax1 = fig.add_subplot(1,2,1)

fixATF=TF.subs(a,3)

SIS.dibujarEjes(ax1,5,[[-5,5],[-25,25]])
SIS.dibujarPolosCeros(ax1,[[-20,5],[-5,5]],fixATF.subs(b,1),1)
ax1.annotate('a1',(-2,1),(-2,1),c='g')

SIS.dibujarPolosCeros(ax1,[[-5,5],[-25,25]],fixATF.subs(b,5),0.8)
ax1.annotate('a2',(-2,5),(-2,5),c='y')

SIS.dibujarPolosCeros(ax1,[[-5,5],[-25,25]],fixATF.subs(b,15),0.6)
ax1.annotate('a3',(-2,15),(-2,15),c='b')

fig = plt.figure(figsize = (10,5))
cx = fig.add_subplot(1,2,1)

solvep,t=SIS.inversaLaplace(fixATF.subs(b,1),1)
valuesSystem = [solvep.subs(t, val) for val in np.arange(0.0, 10.0, 0.1)]
cx.plot(np.arange(0.0, 10.0, 0.1), valuesSystem,'g')
cx.annotate('a1',(1.2,0.08),(1.2,0.08),c='g')

solvep,t=SIS.inversaLaplace(fixATF.subs(b,5),1)
valuesSystem = [solvep.subs(t, val) for val in np.arange(0.0, 10.0, 0.1)]
cx.plot(np.arange(0.0, 10.0, 0.1), valuesSystem,'y')
cx.annotate('a2',(0.6,0.03),(0.6,0.03),c='y')

solvep,t=SIS.inversaLaplace(fixATF.subs(b,15),1)
valuesSystem = [solvep.subs(t, val) for val in np.arange(0.0, 10.0, 0.1)]
cx.plot(np.arange(0.0, 10.0, 0.1), valuesSystem,'b')
cx.annotate('a3',(0.2,0.02),(0.2,0.02),c='b')

"""Cuanto mayor es el valor Im del polo, mayor la oscilación."""

fig = plt.figure(figsize = (10,5))
cx = fig.add_subplot(1,2,1)
fixATF=TF.subs(a,1)
solvep,t=SIS.inversaLaplace(fixATF.subs(b,26),1)
valuesSystem = [solvep.subs(t, val) for val in np.arange(0.0, 10.0, 0.1)]
cx.plot(np.arange(0.0, 10.0, 0.1), valuesSystem,'g')