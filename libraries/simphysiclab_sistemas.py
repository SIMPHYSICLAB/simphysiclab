# -*- coding: utf-8 -*-
"""simphysiclab_sistemas.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YiQ-cPUXQ_8TW0ANa1E60WqKIvHAwRsh

# <font color="darkorange">Librería SISTEMAS de SIMPHYSICLAB</font>

**Autoría**:

*   Eduardo Iáñez (eianez@umh.es)
*   Vicente Quiles (vquiles@umh.es)
*   Federico Botella (federico@umh.es)

Departamento de Ingeniería de Sistemas y Automática.

Universidad Miguel Hernández de Elche.


**Financiación**: El material que aparece a continuación se ha desarrollado dentro del marco del proyecto UNIDIGITAL- SIMPHYSICLAB.

<small><img src=https://raw.githubusercontent.com/SIMPHYSICLAB/simphysiclab/main/images/logo_unidigital_simphysiclab.png></small>

**Fecha última edición**: 15/06/2023

**Licencia**: <small><a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" /></a><br /></small>

*No olvides hacer una copia si deseas utilizarlo. Al usar estos contenidos, aceptas nuestros términos de uso y nuestra política de privacidad.*

### <font color="darkorange">Introducción</font>

En este fichero .py pueden encontrarse todas las funciones desarrolladas para la librería SISTEMAS dentro del proyecto SIMPHYSICLAB. No es por tanto un cuaderno al uso sino que será cargado en cada cuaderno del proyecto para poder utilizar dichas funciones.

**Las funciones están relacionadas con ...**

### <font color="darkorange">Librerias de python necesarias para el funcionamiento de las funciones</font>
"""

# Commented out IPython magic to ensure Python compatibility.
#Standard Python libraries:
import math
import random
import time
import copy
import numpy as np

#Specific control system python libraries:
import control
import sympy
from tbcontrol.symbolic import routh

#Plot python graphic libraries and interactive
import matplotlib
# %matplotlib ipympl
sympy.init_printing()
import matplotlib.pyplot as plt
import matplotlib.path as mpath
import matplotlib.colors as colors
from matplotlib.animation import FuncAnimation
from IPython.display import HTML


from google.colab import output
output.enable_custom_widget_manager()
import ipywidgets as widgets

"""### <font color="darkorange">Funciones para la generación y representación del sistema</font>

### <font color="darkorange">Funciones auxiliares</font>
"""

def tipoLibreria(TF):
  '''
  input:
        TF: función de transferencia.
  output:
        libreria: nombre de la librería principal de la función de transferencia.
  código:
        def tipoLibreria(TF):
          libreria=type(TF).__module__.split('.')[0]
          return libreria
  '''
  libreria=type(TF).__module__.split('.')[0]
  return libreria

def parametrosLibreriaEnTF(TF):
  '''
  input:
        TF: función de transferencia.
  output:
        libreria: nombre de la librería si TF tubiera algun parametro.
  código:
        if tipoLibreria(TF)=="sympy":
          symbolappearance=[]
          num,den,gain=InfoTF("num_den",TF)
          return parametrosLibereriaEnPol(num,den)
        else:
          return "other"
  '''

  if tipoLibreria(TF)=="sympy":
    symbolappearance=[]
    num,den,gain=InfoTF("num_den",TF)
    return parametrosLibereriaEnPol(num,den)
  else:
    return "other"

def parametrosLibereriaEnPol(num,den):
  '''
  input:
        num: numerador de TF
        den: denominador de TF
  output:
        libreria: nombre de la librería si num or den tubieran algun parametro.
  código:
        symbolappearance=[]
        for i in np.concatenate((num, den), axis=0):
            try:
              testrealnumber=float(i)
              symbolappearance.append(0)
            except:
              symbolappearance.append(1)
        if symbolappearance.count(1)>0:
          return "sympy"
        else:
          return "other"
  '''
  symbolappearance=[]
  for i in np.concatenate((num, den), axis=0):
      try:
        testrealnumber=float(np.real(i))
        symbolappearance.append(0)
      except:
        symbolappearance.append(1)
  if symbolappearance.count(1)>0:
    return "sympy"
  else:
    return "other"

#Crear funcion de transfercia generica ya sea G o H
def generarTF(tipo,num,den,simbol=0):
  '''
    input:
          G: función de transferencia G.
          H: función de transferencia H.
          k: valor de retroalimentación k, que puede ser simbólico o noo.
    output:
          M: función retroalimentada.
    código:
          if tipo=="num_den":
            symbolappearance=[]
            #Comprobar si contiene algun simbolico la expresión
            for i in np.concatenate((num, den), axis=0):
              try:
                testrealnumber=float(i)
                symbolappearance.append(0)
              except:
                symbolappearance.append(1)

            #Contiene simbolicos#La expresión simbolica no se puede simplificar
            if (symbolappearance.count(1)!=len(np.concatenate((num, den), axis=0)) and symbolappearance.count(1)>0) or (simbol==1):
              s = sympy.Symbol('s')
              return sympy.factor(sympy.simplify(sympy.Poly(num, s)/sympy.Poly(den, s)))
            #Contiene simbolicos#Se puede simplificar la expresión simbolica
            elif symbolappearance.count(1)==len(np.concatenate((num, den), axis=0)) and symbolappearance.count(1)>0:
              numwithoutParameter=[]
              denwithoutParameter=[]
              for i in num:
                if len(i.atoms(sympy.Number))==0:
                  numwithoutParameter.append(float(1))
                else:
                  numwithoutParameter.append(float(i.atoms(sympy.Number).pop()))
              for i in den:
                if len(i.atoms(sympy.Number))==0:
                  denwithoutParameter.append(float(1))
                else:
                  denwithoutParameter.append(float(i.atoms(sympy.Number).pop()))

              return control.tf(numwithoutParameter, denwithoutParameter)
            #No contiene simbolicos
            else:
              #Este cast es por si simpy guarda los valores en un formato distinto de float
              numcastfloat=[]
              dencastfloat=[]
              for i in num:
                numcastfloat.append(float(i))
              for i in den:
                dencastfloat.append(float(i))
              #Crear la función de transferencia con los valores guardados en formato float
              return control.tf(numcastfloat, dencastfloat)
          elif tipo =="ceros_polos":
            if parametrosLibereriaEnPol(num,den)=="sympy":
              print("Error")
              return "Error."
            else:
              if simbol==0:
                s = control.tf('s')
                numcp = 1
                dencp = 1
                if len(num)==0 and len(den)==0:
                  TF=control.tf(1, 1)
                else:
                  for i in range(len(num)):
                    numcp = numcp * (s - num[i])
                  for j in range(len(den)):
                    dencp = dencp * (s - den[j])
                  TF=numcp/dencp
              elif simbol==1:
                s=sympy.symbols('s')
                numcp = 1
                dencp = 1
                if len(num)==0 and len(den)==0:
                  TF=sympy.factor(numcp/dencp)
                else:
                  for i in range(len(num)):
                    numcp = numcp * (s - num[i])
                  for j in range(len(den)):
                    dencp = dencp * (s - den[j])
                  TF=sympy.factor(numcp/dencp)

            return TF
  '''
  if tipo=="num_den":
    symbolappearance=[]
    #Comprobar si contiene algun simbolico la expresión
    for i in np.concatenate((num, den), axis=0):
      try:
        testrealnumber=float(np.real(i))
        symbolappearance.append(0)
      except:
        symbolappearance.append(1)

    #Contiene simbolicos#La expresión simbolica no se puede simplificar
    if (symbolappearance.count(1)!=len(np.concatenate((num, den), axis=0)) and symbolappearance.count(1)>0) or (simbol==1):
      s = sympy.Symbol('s')

      #numnew=[]
      #dennew=[]

      #for n in num:
      #  numnew.append(int(n))
      #for d in den:
      #  dennew.append(int(d))

      return sympy.factor(sympy.simplify(sympy.Poly(num, s)/sympy.Poly(den, s)))
      #return sympy.Poly(numnew, s)/sympy.Poly(dennew, s)
    #Contiene simbolicos#Se puede simplificar la expresión simbolica
    elif symbolappearance.count(1)==len(np.concatenate((num, den), axis=0)) and symbolappearance.count(1)>0:
      numwithoutParameter=[]
      denwithoutParameter=[]
      for i in num:
        if len(i.atoms(sympy.Number))==0:
          numwithoutParameter.append(float(1))
        else:
          numwithoutParameter.append(float(i.atoms(sympy.Number).pop()))
      for i in den:
        if len(i.atoms(sympy.Number))==0:
          denwithoutParameter.append(float(1))
        else:
          denwithoutParameter.append(float(i.atoms(sympy.Number).pop()))

      return control.tf(numwithoutParameter, denwithoutParameter)
    #No contiene simbolicos
    else:
      #Este cast es por si simpy guarda los valores en un formato distinto de float
      numcastfloat=[]
      dencastfloat=[]
      for i in num:
        numcastfloat.append(float(i))
      for i in den:
        dencastfloat.append(float(i))

      #Cancelación en base a sympy
      TF=generarTF("num_den",numcastfloat,dencastfloat,1)
      TF=sympy.cancel(TF)

      #Cancelación en base a ceros polos
      ceros,polos,gain=InfoTF("ceros_polos",TF)
      ceros,polos=cancelar_ceros_y_polos(ceros, polos)
      TF=float(gain)*generarTF("ceros_polos",ceros,polos,1)

      #Forzado manual a control porque sino se entra en bucle
      num,den,gain=InfoTF("num_den",TF)
      numcK=[]
      for i in num:
        numcK.append(float(np.real(i))*float(np.real(gain)))
      denc=[]
      for i in den:
        denc.append(float(np.real(i)))

      #Crear la función de transferencia con los valores guardados en formato float
      return control.tf(numcK, denc)
  elif tipo =="ceros_polos":
    if parametrosLibereriaEnPol(num,den)=="sympy":
      s=sympy.symbols('s')
      numcp = 1
      dencp = 1
      if len(num)==0 and len(den)==0:
        TF=sympy.factor(numcp/dencp)
      else:
        for i in range(len(num)):
          numcp = numcp * (s - num[i])
        for j in range(len(den)):
          dencp = dencp * (s - den[j])
        TF=sympy.factor(numcp/dencp)
    else:
      if simbol==0:
        s = control.tf('s')
        numcp = 1
        dencp = 1
        if len(num)==0 and len(den)==0:
          TF=control.tf(1, 1)
          return TF
        else:
          for i in range(len(num)):
            numcp = numcp * (s - num[i])
          for j in range(len(den)):
            dencp = dencp * (s - den[j])


        #Forzado manual a control porque sino se entra en bucle
        ceros,polos,gain=InfoTF("ceros_polos",numcp/dencp)
        ceros,polos=cancelar_ceros_y_polos(ceros, polos)
        TF=float(gain)*generarTF("ceros_polos",ceros,polos,1)
        #Forzado manual a control porque sino se entra en bucle

        return forzarTFControl(TF)
      elif simbol==1:
        s=sympy.symbols('s')
        if len(num)==0 and len(den)==0:
          numcp = 1
          dencp = 1
          TF=sympy.factor(numcp/dencp)
        else:
          numcp = 1
          dencp = 1
          for i in range(len(num)):
            numcp = numcp * (s - num[i])
          for j in range(len(den)):
            dencp = dencp * (s - den[j])
          TF=sympy.factor(numcp/dencp)
          #Forzado manual a sympy porque sino se entra en bucle
          ceros,polos,gain=InfoTF("ceros_polos",TF)
          ceros,polos=cancelar_ceros_y_polos(ceros, polos)
          numcp = 1
          dencp = 1
          for i in range(len(ceros)):
            numcp = numcp * (s - ceros[i])
          for j in range(len(polos)):
            dencp = dencp * (s - polos[j])
          TF=sympy.factor(numcp/dencp)
          #Forzado manual a sympy porque sino se entra en bucle
    return TF
def cancelar_ceros_y_polos(ceros, polos, roundnumber=4,tolerancia=1e-4):

    cerosLibreria=[]
    polosLibreria=[]
    for c in ceros:
      if tipoLibreria(c)=="sympy":
        cerosLibreria.append((round(c.as_real_imag()[0],roundnumber)+round(c.as_real_imag()[1],roundnumber)*sympy.I))
      else:
        cerosLibreria.append(complex(round(np.real(c),roundnumber),round(np.imag(c),roundnumber)))
    for p in polos:
      if tipoLibreria(p)=="sympy":
        polosLibreria.append((round(p.as_real_imag()[0],roundnumber)+round(p.as_real_imag()[1],roundnumber)*sympy.I))
      else:
        polosLibreria.append(complex(round(np.real(p),roundnumber),round(np.imag(p),roundnumber)))

    ceros=cerosLibreria
    polos=polosLibreria

    ceros_a_remover = []
    polos_a_remover = []
    if len(ceros)!=0:
      for cero in ceros:
          for polo in polos:
              if abs(cero - polo) < tolerancia:
                  ceros_a_remover.append(cero)
                  polos_a_remover.append(polo)
                  break  # Salir después de encontrar una coincidencia para evitar múltiples cancelaciones

      # Remover los ceros y polos coincidentes
      for cero in ceros_a_remover:
          ceros.remove(cero)

      for polo in polos_a_remover:
          polos.remove(polo)
    return ceros, polos

def forzarTFSympy(TF):
  #Forzar libreria sympy
  if parametrosLibreriaEnTF(TF)=="sympy":
    num,den,gain=InfoTF("num_den",TF)
    numcK=[]
    for i in num:
      numcK.append(i*gain)
    num=generarTF("num_den",numcK,[1],1)
    den=generarTF("num_den",den,[1],1)
    TF=num/den
  else:
    num,den,gain=InfoTF("num_den",TF)
    numcK=[]
    for i in num:
      numcK.append(float(i)*float(gain))
    num=generarTF("num_den",numcK,[1],1)
    den=generarTF("num_den",den,[1],1)
    TF=num/den
  #Forzar libreria sympy
  return TF

def forzarTFControl(TF):
  #Forzar libreria control
  num,den,gain=InfoTF("num_den",TF)

  numcK=[]
  for i in num:
    numcK.append(i*gain)
  denc=[]
  for i in den:
    denc.append(i)
  TF=generarTF("num_den",numcK,denc)
  #Forzar libreria control
  return TF

def InfoTF(tipo,TF):

    '''
    input:
          G: función de transferencia G.
          H: función de transferencia H.
          k: valor de retroalimentación k, que puede ser simbólico o noo.
    output:
          M: función retroalimentada.
    código:
          if tipo=="num_den":
            num=[]
            den=[]

            if tipoLibreria(TF)=="sympy":
              n,d = sympy.fraction(TF)
              num=sympy.Poly(n, sympy.symbols('s')).all_coeffs()
              den=sympy.Poly(d, sympy.symbols('s')).all_coeffs()

              gain=num[0]
              denCoeff=den[0]

              numSimplify=[]
              denSimplify=[]

              for i in num:
                numSimplify.append(i/gain)
              for i in den:
                denSimplify.append(i)
              return numSimplify,denSimplify,gain
            else:

              gain=TF.num[0][0][0]

              for i in TF.num[0][0]:
                num.append(i.real/gain)
              for i in TF.den[0][0]:
                den.append(i.real)
              return num,den,gain
          elif tipo =="ceros_polos":
            if tipoLibreria(TF)=="sympy":
              n,d = sympy.fraction(TF)
              gain=sympy.Poly(n, sympy.symbols('s')).coeffs()[0]
              num=sympy.Poly(n, sympy.symbols('s'))
              den=sympy.Poly(d, sympy.symbols('s'))
              ceros=sympy.solve(num,sympy.symbols('s'))
              polos=sympy.solve(den,sympy.symbols('s'))
              return ceros,polos,gain
            else:
              gain=TF.num[0][0][0]
              ceros=TF.zeros()
              ceros=[np.round(i,8) for i in ceros]
              polos=TF.poles()
              polos=[np.round(i,8) for i in polos]
              return ceros,polos,gain
    '''
    if tipo=="num_den":
      num=[]
      den=[]

      if tipoLibreria(TF)=="sympy":
        n,d = sympy.fraction(TF)
        num=sympy.Poly(n, sympy.symbols('s')).all_coeffs()
        den=sympy.Poly(d, sympy.symbols('s')).all_coeffs()

        gain=num[0]
        denCoeff=den[0]

        numSimplify=[]
        denSimplify=[]

        #!!Cambio en el denominador
        #for i in num:
        #  numSimplify.append(i/gain)
        #for i in den:
        #  denSimplify.append(i)

        for i in num:
          numSimplify.append((i/gain)/denCoeff)
        for i in den:
          denSimplify.append((i)/denCoeff)
        return numSimplify,denSimplify,gain
      else:
        #!!Cambio en el denominador
        #gain=TF.num[0][0][0]
        #for i in TF.num[0][0]:
        #  num.append(i.real/gain)
        #for i in TF.den[0][0]:
        #  den.append(i.real)
        #return num,den,gain

        gain=TF.num[0][0][0]
        denCoeff=TF.den[0][0][0]

        for i in TF.num[0][0]:
          num.append((i.real/gain)/denCoeff)
        for i in TF.den[0][0]:
          den.append((i.real)/denCoeff)
        return num,den,gain
    elif tipo =="ceros_polos":
      if tipoLibreria(TF)=="sympy":
        n,d = sympy.fraction(TF)
        #!!Cambio en el denominador
        #gain=sympy.Poly(n, sympy.symbols('s')).coeffs()[0]
        gain=sympy.Poly(n, sympy.symbols('s')).coeffs()[0]/sympy.Poly(d, sympy.symbols('s')).coeffs()[0]
        num=sympy.Poly(n, sympy.symbols('s'))
        den=sympy.Poly(d, sympy.symbols('s'))

        #cerossympy=sympy.solve(num,sympy.symbols('s'))
        cerossympy=sympy.roots(num,sympy.symbols('s'))
        ceros = devolverPolos_Ceros(cerossympy)
        #polossympy=sympy.solve(den,sympy.symbols('s'))
        polossympy=sympy.roots(den,sympy.symbols('s'))
        polos = devolverPolos_Ceros(polossympy)

        return ceros,polos,gain
      else:
        #!!Cambio en el denominador
        #gain=TF.num[0][0][0]
        gain=TF.num[0][0][0]/TF.den[0][0][0]
        ceros=TF.zeros()
        ceros=[np.round(i,4) for i in ceros]
        polos=TF.poles()
        polos=[np.round(i,4) for i in polos]
        return ceros,polos,gain

def devolverPolos_Ceros(polosCeros):
    all_cerosOrpoles = []
    print("polosCeros",polosCeros)
    if hasattr(polosCeros, 'keys') and hasattr(polosCeros, 'values'):
      pole_values = list(polosCeros.keys())
      multiplicities = list(polosCeros.values())
      for i in range(len(pole_values)):
          current_pole = pole_values[i]
          current_multiplicity = multiplicities[i]
          all_cerosOrpoles.extend([current_pole] * current_multiplicity)
    else:
      all_cerosOrpoles=polosCeros
    return all_cerosOrpoles

def realimentacion(G,H,k=1):

    '''
      input:
            G: función de transferencia G.
            H: función de transferencia H.
            k: valor de retroalimentación k, que puede ser simbólico o noo.
      output:
            M: función retroalimentada.

      código:
            if (parametrosLibreriaEnTF(G)=="sympy" or parametrosLibreriaEnTF(H)=="sympy") and tipoLibreria(k)=="sympy":
              #print("1")
              num,den,gain=InfoTF("num_den",G)
              numk=[]
              for i in num:
                numk.append(i*k)
              G=gain*generarTF("num_den",numk,den)
              H,num,den,gain=InfoTF("num_den",H)
              H=gain*generarTF("num_den",num,den,1)
              M=(G/(1+(G*H)))
              M=sympy.simplify(M)
              return M
            elif (parametrosLibreriaEnTF(G)=="sympy" or parametrosLibreriaEnTF(H)=="sympy") and tipoLibreria(k)!="sympy":
              #print("2")
              num,den,gain=InfoTF("num_den",G)
              numk=[]
              for i in num:
                numk.append(i*k)
              G=gain*generarTF("num_den",numk,den,1)
              num,den,gain=InfoTF("num_den",H)
              H=gain*generarTF("num_den",num,den,1)
              M=(G/(1+(G*H)))
              M=sympy.simplify(M)
              return M
            elif (parametrosLibreriaEnTF(G)!="sympy" and parametrosLibreriaEnTF(H)!="sympy") and tipoLibreria(k)=="sympy":
              #print("3")
              num,den,gain=InfoTF("num_den",G)
              numk=[]
              for i in num:
                numk.append(i*k)
              G=gain*generarTF("num_den",numk,den,1)
              num,den,gain=InfoTF("num_den",H)
              H=gain*generarTF("num_den",num,den,1)
              M=(G/(1+(G*H)))
              M=sympy.simplify(M)
              return M
            elif (parametrosLibreriaEnTF(G)!="sympy" and parametrosLibreriaEnTF(H)!="sympy") and tipoLibreria(k)!="sympy":
              numG,denG,gainG=InfoTF("num_den",G)
              numH,denH,gainH=InfoTF("num_den",H)
              if tipoLibreria(G)=="sympy" and tipoLibreria(H)=="sympy":
                numk=[]
                for i in numG:
                  numk.append(i*k)
                G=gainG*generarTF("num_den",numk,denG,1)
                H=gainH*generarTF("num_den",numH,denH,1)
                M=((G)/(1+(G*H)))
                M=sympy.simplify(M)
              else:
                G=gainG*generarTF("num_den",numG,denG)
                H=gainH*generarTF("num_den",numH,denH)
                K_G=control.series(k,G)
                M=control.feedback(K_G,H)
                ceros,polos,gain=InfoTF("ceros_polos",M)
              return M
    '''

    if (parametrosLibreriaEnTF(G)=="sympy" or parametrosLibreriaEnTF(H)=="sympy") and tipoLibreria(k)=="sympy":
      #Caso en el que el primer sistema es tipo sympy, el segundo también y el parametro K también.
      num,den,gain=InfoTF("num_den",G)
      numk=[]
      for i in num:
        numk.append(i*k)
      G=gain*generarTF("num_den",numk,den)
      H,num,den,gain=InfoTF("num_den",H)
      H=gain*generarTF("num_den",num,den,1)
      M=(G/(1+(G*H)))
      M=sympy.simplify(M)
      return M
    elif (parametrosLibreriaEnTF(G)=="sympy" or parametrosLibreriaEnTF(H)=="sympy") and tipoLibreria(k)!="sympy":
      #Caso en el que el primer sistema es tipo sympy, el segundo también pero el parametro K no.
      num,den,gain=InfoTF("num_den",G)
      numk=[]
      for i in num:
        numk.append(i*k)
      G=gain*generarTF("num_den",numk,den,1)
      num,den,gain=InfoTF("num_den",H)
      H=gain*generarTF("num_den",num,den,1)
      M=(G/(1+(G*H)))
      M=sympy.simplify(M)
      return M
    elif (parametrosLibreriaEnTF(G)!="sympy" and parametrosLibreriaEnTF(H)!="sympy") and tipoLibreria(k)=="sympy":
      #Caso en el que el primer sistema no es tipo sympy, el segundo tampoco pero el parametro K sí.
      num,den,gain=InfoTF("num_den",G)
      numk=[]
      for i in num:
        numk.append(i*k)
      G=gain*generarTF("num_den",numk,den,1)
      num,den,gain=InfoTF("num_den",H)
      H=gain*generarTF("num_den",num,den,1)
      M=(G/(1+(G*H)))
      M=sympy.simplify(M)
      return M
    elif (parametrosLibreriaEnTF(G)!="sympy" and parametrosLibreriaEnTF(H)!="sympy") and tipoLibreria(k)!="sympy":
      #Caso en el que el primer sistema no es tipo sympy, el segundo tampoco y el parametro K tampoco.
      numG,denG,gainG=InfoTF("num_den",G)
      numH,denH,gainH=InfoTF("num_den",H)
      #Si no hay parametro pero el sistema se creó con sympy
      if tipoLibreria(G)=="sympy" and tipoLibreria(H)=="sympy":
        numk=[]
        for i in numG:
          numk.append(i*k)
        G=gainG*generarTF("num_den",numk,denG,1)
        H=gainH*generarTF("num_den",numH,denH,1)
        M=((G)/(1+(G*H)))
        M=sympy.simplify(M)
      else:#Si el sistema se creó con control
        G=gainG*generarTF("num_den",numG,denG)
        H=gainH*generarTF("num_den",numH,denH)
        K_G=control.series(k,G)
        M=control.feedback(K_G,H)

        M=forzarTFSympy(M)
        M=sympy.simplify(M)
        M=forzarTFControl(M)

        ceros,polos,gain=InfoTF("ceros_polos",M)
      return M

def ordenTF(TF):

  '''
    input:
          TF: función de transferencia.
    output:
          orden:orden del denominador del polinomio.

    código:
          num,den,gain=InfoTF("num_den",TF)
          orden=len(den)-1
          return orden
  '''

  num,den,gain=InfoTF("num_den",TF)
  orden=len(den)-1
  return orden

def inversaLaplace(TF,positivos,G=None):

  '''
    input:
          TF: función de transferencia.
          positivos: restingir a evaluar solo valors positivos
    output:
          inverse_laplace_transform: devuelve la transformada inversa de laplace

    código:
          #Forzar libreria sympy
          num,den,gain=InfoTF("num_den",TF)

          numcK=[]
          for i in num:
            numcK.append(float(i)*gain)
          denc=[]
          for i in den:
            denc.append(float(i))
          TF=generarTF("num_den",numcK,denc,1)
          #Forzar libreria sympy

          if positivos==1:
            s = sympy.symbols('s')
            t = sympy.Symbol('t', positive=True)
          else:
            s = sympy.symbols('s')
            t = sympy.Symbol('t')
          return sympy.inverse_laplace_transform(TF, s, t)
  '''

  TF=forzarTFSympy(TF)

  if positivos==1:
    s = sympy.symbols('s')
    t = sympy.Symbol('t',real=True,positive=True)
  else:
    s = sympy.symbols('s')
    t = sympy.Symbol('t')

  if G==None:
    return sympy.inverse_laplace_transform(TF, s, t),t
  else:
    G=forzarTFControl(G)

    tv,yv=control.step_response(G,100)
    invL=sympy.inverse_laplace_transform(TF, s, t)
    valuesSystem = [invL.subs(t, val) for val in np.arange(0, 100, 0.0423908435777872)]
    irange=min([len(valuesSystem),len(yv)])
    newVectorDifference=[]
    for i in range(irange):
      newVectorDifference.append(abs(valuesSystem[i]-yv[i]))
    if sum(newVectorDifference)/len(newVectorDifference)<0.1:
      return invL,t,"NotError"
    else:
      return invL,t,newVectorDifference

def inversaLaplacePorPartes(TF):

  TF=forzarTFSympy(TF)

  print("Se analiza el sistema por partes.")
  gt,t=inversaLaplace(TF,1)
  term_list = sympy.Add(gt).as_ordered_terms()
  term_TF= sympy.Add(TF.apart()).as_ordered_terms()
  factors = term_list
  for j in range(0,len(factors)):

    if estabilidadTF(term_TF[j])==1:
      print("Factor: "+str(j+1),"Parte de G: ",term_TF[j],"Inversa Laplace: ",factors[j],".Estable.")
    else:
      print("Factor: "+str(j+1),"Parte de G: ",term_TF[j],"Inversa Laplace: ",factors[j],".Inestable.")
    x=[]
    y=[]
    for i in range(0, 1000):
        x.append(i*0.1)
        y.append(float(factors[j].subs(t, i*0.1)))
    plt.figure("Inversa Laplace de factor: "+str(j+1))
    plt.plot(x,y)

  x=[]
  y=[]
  invLG,t=inversaLaplace(TF,1)

  for i in range(0, 1000):
    x.append(i*0.1)
    ff=invLG.subs(t, i*0.1)
    y.append(float(ff))
  plt.figure("Inversa de Laplace de todo el sistema")
  plt.plot(x,y)

def estabilidadTF(TF):

  '''
    input:
          TF: función de transferencia.
    output:

    código:
          if parametrosLibreriaEnTF(TF)=="sympy":
            print("La estabilidad con esta función solo se puede estudiar sin parametros variables.")
          else:
            ceros,polos,gain=InfoTF("ceros_polos",TF)
            ceros=[np.round(float(i),2) for i in ceros]
            polos=[np.round(float(i),2) for i in polos]
            EstableInestable=0
            for i in polos:
              if i.real>=0:
                if EstableInestable==0:
                  print("Sistema Inestable")
                  EstableInestable=1
                print("Polo inestable en:",i,", ")
            if EstableInestable==0:
              print("Sistema Estable")
  '''

  if parametrosLibreriaEnTF(TF)=="sympy":
    print("La estabilidad con esta función solo se puede estudiar sin parametros variables.")
  else:
    ceros,polos,gain=InfoTF("ceros_polos",TF)
    ceros=[np.round(float(np.real(i)),2) for i in ceros]
    polos=[np.round(float(np.real(i)),2) for i in polos]
    EstableInestable=0
    for i in polos:
      if i>=0:
        if EstableInestable==0:
          print("Sistema Inestable")
          EstableInestable=1
        print("Polo inestable en:",i,", ")
    if EstableInestable==0:
      print("Sistema Estable")
      return 1
    else:
      return 0

def estabilidadCardano(TF):

  '''
    input:
          TF: función de transferencia.
    output:

    código:
          num,den,gain=SIS.InfoTF("num_den",TF)

          coeffs = []
          for d in den:
            if d.atoms(sympy.Number)==set():
              coeffs.append(1)
            else:
              coeffs.append(d)

          has_zero = any(x == 0 for x in coeffs)
          if has_zero!=True:
            lastValue=np.sign(coeffs)
            indices = np.where(lastValue < 0)
            if len(indices)==0:
              print("Pasa los dos criterios de Cardano, se debe analizar la estabilidad según Ruth para asegurar Estabilidad.")
            else:
              print("Inestable. Falló el segundo criterio de Cardano.")
          else:
            print("Inestable. Falló el primer criterio de Cardano.")
  '''

  num,den,gain=InfoTF("num_den",TF)

  coeffs = []
  for d in den:
    if d.atoms(sympy.Number)==set():
      coeffs.append(1)
    else:
      coeffs.append(d)

  has_zero = any(x == 0 for x in coeffs)
  if has_zero!=True:
    lastValue=np.sign(coeffs)
    indices = np.where(lastValue < 0)
    if len(indices[0])==0:
      print("Cumple los dos criterios de Cardano, se debe analizar la estabilidad según Routh para asegurar Estabilidad.")
    else:
      print("Inestable. No cumple el segundo criterio de Cardano.")
  else:
    print("Inestable. No cumple el primer criterio de Cardano.")

def estabilidadRouth(TF,simbolo=None):

  '''
    input:
          TF: función de transferencia.
          símbolo: símbolo a evaluar dentro de la función de transferencia.
    output:

    código:
          s = sympy.symbols('s')

          #Forzar libreria sympy
          num,den,gain=InfoTF("num_den",TF)
          #Forzar libreria sympy

          A = routh(sympy.Poly(den, s))

          print(A)

          zero_row_indices = [i for i, row in enumerate(A.tolist()) if all(element == 0 for element in row)]


          if any(zero_row_indices):
            print("fila de ceros")
          else:
            if parametrosLibereriaEnPol([1],den)=="sympy":
              for e in A[:, 0]:
                print("routh row: ",e)
                rowSolution=sympy.solve(e>0,simbolo)
                if rowSolution!=[]:
                  solution_set=rowSolution.as_set()
                  down_Limit = solution_set.args[0]
                  upper_Limit = solution_set.args[1]
                  print("row To row, Solution: ",rowSolution,down_Limit,upper_Limit)
              routhSolution=sympy.solve([e > 0 for e in A[:, 0]], simbolo)
              solution_set=routhSolution.as_set()
              down_Limit = solution_set.args[0]
              upper_Limit = solution_set.args[1]
              print("global, Solution:",routhSolution,down_Limit,upper_Limit)
            else:
              if any([e < 0 for e in A[:,0]]) and any([e != None for e in A[:,0]]):
                a=A[:,0]
                vector=np.transpose(a)
                lastValue=np.sign(vector[0])
                indices = np.where(lastValue < 0)
                print("inestable, cambios de signo en:",indices[0])
              else:
                print("estable")
  '''

  s = sympy.symbols('s')

  num,den,gain=InfoTF("num_den",TF)

  A = routh(sympy.Poly(den, s))

  print(A)

  zero_row_indices = [i for i, row in enumerate(A.tolist()) if all(element == 0 for element in row)]


  if any(zero_row_indices):
    print("fila de ceros")
  else:
    if parametrosLibereriaEnPol([1],den)=="sympy":
      for e in A[:, 0]:
        print("routh row: ",e)
        rowSolution=sympy.solve(e>0,simbolo)
        if rowSolution!=[]:
          solution_set=rowSolution.as_set()
          down_Limit = solution_set.args[0]
          upper_Limit = solution_set.args[1]
          print("row To row, Solution: ",rowSolution,down_Limit,upper_Limit)
      routhSolution=sympy.solve([e > 0 for e in A[:, 0]], simbolo)
      solution_set=routhSolution.as_set()
      down_Limit = solution_set.args[0]
      upper_Limit = solution_set.args[1]
      print("global, Solution:",routhSolution,down_Limit,upper_Limit)
    else:
      if any([e < 0 for e in A[:,0]]) and any([e != None for e in A[:,0]]):
        a=A[:,0]
        vector=np.transpose(a)
        lastValue=np.sign(vector[0])
        indices = np.where(lastValue < 0)
        print("inestable, cambios de signo en:",indices[0])
      else:
        print("estable")

def ecuacionCaracteristicaRouth(filaRouth,gradoPol,potencia):

  """
  input:
        filaRouth: lista de indices de la fila de la tabla de Routh.
        gradoPol: Grado del polinomio máximo.
        potencia: Grado del polinomio de la fila de Routh que se esta evaluando.
  output:
        C: indices arreglados del polinomio caracteristico extraido de la tabla de routh

  código:
        C=[]
        B=list(filaRouth)
        i=0
        longitud=gradoPol-potencia+2
        for x in range(1,longitud):f
          if x%2==0:
            C.append(0)
          else:
            C.append(B[i])
            i=i+1
        return C
  """

  C=[]
  B=list(filaRouth)
  i=0
  longitud=gradoPol-potencia+2
  for x in range(1,longitud):
    if x%2==0:
      C.append(0)
    else:
      C.append(B[i])
      i=i+1
  return C

def routhCasoEspecial(TF):

  '''
    input:
          TF: función de transferencia.
    output:
          A: Tabla de routh arreglada.

    código:
          #Forzar libreria sympy
          num,den,gain=InfoTF("num_den",TF)
          #Forzar libreria sympy

          pol=generarTF("num_den",den,[1],1)

          s = sympy.Symbol('s')
          coefsPar=coeficientesPares(pol)
          coefsImpar=coeficientesImpares(pol)
          A=np.zeros((len(pol), len(coefsPar)))
          for i in range(0,len(coefsPar)):
            A[0,i]=pol[(coefsPar[i])]
          for i in range(0,len(coefsImpar)):
            A[1,i]=pol[(coefsImpar[i])]
          for i in range(2,len(A[:,0])):
            for j in range(0,len(A[0,:])-1):
              A[i,j]=(-1/A[i-1,0])*np.linalg.det(np.array([[A[i-2,0], A[i-2,j+1]], [A[i-1,0], A[i-1,j+1]]]))
            if((np.count_nonzero(A[i,:] == 0)==len(coefsPar))==True):
              res=ecuacionCaracteristicaRouth(A[i-1,:],len(pol),(i))#ecuacionCaracteristicaRouth(A[i-1,:],len(pol),(i-1))
              ec=sympy.Poly(res, s)
              derivative = sympy.diff(ec, s)
              for pij in range(0,len(derivative.coeffs())):
                A[i,pij]=derivative.coeffs()[pij]
          return A

  '''

  num,den,gain=InfoTF("num_den",TF)

  #pol=generarTF("num_den",den,[1],1)
  pol=den

  s = sympy.Symbol('s')
  coefsPar=coeficientesPares(pol)
  coefsImpar=coeficientesImpares(pol)
  A=np.zeros((len(pol), len(coefsPar)))
  for i in range(0,len(coefsPar)):
    A[0,i]=pol[(coefsPar[i])]
  for i in range(0,len(coefsImpar)):
    A[1,i]=pol[(coefsImpar[i])]
  for i in range(2,len(A[:,0])):
    for j in range(0,len(A[0,:])-1):
      A[i,j]=(-1/A[i-1,0])*np.linalg.det(np.array([[A[i-2,0], A[i-2,j+1]], [A[i-1,0], A[i-1,j+1]]]))
    if((np.count_nonzero(A[i,:] == 0)==len(coefsPar))==True):
      res=ecuacionCaracteristicaRouth(A[i-1,:],len(pol),(i))#ecuacionCaracteristicaRouth(A[i-1,:],len(pol),(i-1))
      ec=sympy.Poly(res, s)
      print('Polinomio anterior a la fila de ceros:',ec)
      derivative = sympy.diff(ec, s)
      print('Derivada del polinomio:',derivative)
      for pij in range(0,len(derivative.coeffs())):
        A[i,pij]=derivative.coeffs()[pij]
  return A

def coeficientesPares(polinomio):

  '''
    input:
          polinomio: polinomio de la tabla de routh que se va a evaluar.
    output:
          polPar: Índices impares del polinomio.

    código:
          polPar=[]
          for i in range(0,len(polinomio), 2):
            polPar.append(i)
          return polPar
  '''

  polPar=[]
  for i in range(0,len(polinomio), 2):
    polPar.append(i)
  return polPar

def coeficientesImpares(polinomio):

  '''
    input:
          polinomio: polinomio de la tabla de routh que se va a evaluar.
    output:
          polImpar: Índices impares del polinomio.
    código:
          polImpar=[]
          for i in range(1,len(polinomio), 2):
            polImpar.append(i)
          return polImpar
  '''

  polImpar=[]
  for i in range(1,len(polinomio), 2):
    polImpar.append(i)
  return polImpar

def respuestaEscalon(ax,TF,tiempo):

  '''
    input:
          ax: ventana donde se dibujará la imagen.
          TF: función de transferencia.
          tiempo: tiempo máximo de la respuesta de la función de transferencia.
    output:
          y: respuesta de la función de transferencia.
          t: vector de tiempo de la función de transferencia.

    código:
          #Forzar libreria control
          num,den,gain=InfoTF("num_den",TF)

          numcK=[]
          for i in num:
            numcK.append(float(i)*gain)
          denc=[]
          for i in den:
            denc.append(float(i))
          TF=generarTF("num_den",numcK,denc)
          #Forzar libreria control

          t,y=control.step_response(TF,tiempo)
          ax.plot(t,y)
          return y,t
  '''

  TF=forzarTFControl(TF)

  t,y=control.step_response(TF,tiempo)
  ax.plot(t,y)
  return y,t

def ajustarLimites(limites):
  """
  input:
        limites: formato de entrada en el que pueden faltar algun componente de los cuatro valores [[-x,x],[-y,y]].
  output:
        xmin,xmax,ymin,ymax: devuelve los cuatro valores arreglados
  """
  xmax=0
  xmin=0
  ymax=0
  ymin=0

  #arreglar limites para X
  valuesX=limites[0]
  if len(valuesX)==2:
    xmin = min(valuesX)
    xmax = max(valuesX)
  else:
    if valuesX[0]<0:
      xmin=valuesX[0]
      xmax=-valuesX[0]
    else:
      xmin=-valuesX[0]
      xmax=1
  #arreglar limites para Y
  valuesY=limites[1]
  if len(valuesY)==2:
    ymin = min(valuesY)
    ymax = max(valuesY)
  else:
    if valuesY[0]<0:
      ymin=valuesY[0]
      ymax=-valuesY[0]
    else:
      ymin=-valuesY[0]
      ymax=valuesY[0]
  return xmin,xmax,ymin,ymax

def dibujarEjes(ax,paso,limites):

  """
  input:
        ax: ventana donde se dibujará la imagen.
        paso: unidad minima de la gradilla.
        limites: formato de entrada en el que pueden faltar algun componente de los cuatro valores [[-x,x],[-y,y]].
  output:
        xmin,xmax,ymin,ymax: devuelve los cuatro valores arreglados.
  código:
        xmin,xmax,ymin,ymax=ajustarLimites(limites)

        ax.set(xlim=(xmin-1, xmax+1), ylim=(ymin-1, ymax+1), aspect='equal')
        # Establecemos en 0,0 el origen del eje de coordenadas para representar
        # las marcas de la escala de los ejes
        ax.spines['bottom'].set_position('zero')
        ax.spines['left'].set_position('zero')
        # Borramos las marcas en un lado de la grafica para mejorar el diseño
        ax.spines['top'].set_visible(False)
        ax.spines['right'].set_visible(False)
        # Escribimos el nombre de cada ejes
        ax.set_xlabel('Real', size=14, labelpad=-24, x=1.03)
        ax.set_ylabel('Im', size=14, labelpad=-21, y=1.02, rotation=0)
        # Creamos las marcas principales personalizadas para determinar la posición
        # de las etiquetas de cada marca
        ticks_frequency = paso
        x_ticks = np.arange(xmin, xmax+1, ticks_frequency)
        y_ticks = np.arange(ymin, ymax+1, ticks_frequency)
        ax.set_xticks(x_ticks[x_ticks != 0])
        ax.set_yticks(y_ticks[y_ticks != 0])
        # Creamos las marcas menores colocadas en cada entero para habilitar el dibujo de
        # las líneas de cuadrícula menores: tenga en cuenta que esto no tiene efecto en
        ax.set_xticks(np.arange(xmin, xmax+1), minor=True)
        ax.set_yticks(np.arange(ymin, ymax+1), minor=True)
        # Dibujamos las lineas de la cuadrícula
        ax.grid(which='both', color='grey', linewidth=1, linestyle='-', alpha=0.2)
        # Dibujamos las flechas
        arrow_fmt = dict(markersize=4, color='black', clip_on=False)
        ax.plot((1), (0), marker='>', transform=ax.get_yaxis_transform(), **arrow_fmt)
        ax.plot((0), (1), marker='^', transform=ax.get_xaxis_transform(), **arrow_fmt)
  """

  xmin,xmax,ymin,ymax=ajustarLimites(limites)

  ax.set(xlim=(xmin-1, xmax+1), ylim=(ymin-1, ymax+1))
  #ax.set(xlim=(xmin-1, xmax+1), ylim=(ymin-1, ymax+1), aspect='equal')
  # Establecemos en 0,0 el origen del eje de coordenadas para representar
  # las marcas de la escala de los ejes
  ax.spines['bottom'].set_position('zero')
  ax.spines['left'].set_position('zero')
  # Borramos las marcas en un lado de la grafica para mejorar el diseño
  ax.spines['top'].set_visible(False)
  ax.spines['right'].set_visible(False)
  # Escribimos el nombre de cada ejes
  ax.set_xlabel('Im', size=6, labelpad=23, x=34.03)
  ax.set_ylabel('Real', size=6, labelpad=-60, y=34.02, rotation=0)
  # Creamos las marcas principales personalizadas para determinar la posición
  # de las etiquetas de cada marca
  ticks_frequency = paso
  x_ticks = np.arange(xmin, xmax+1, ticks_frequency)
  y_ticks = np.arange(ymin, ymax+1, ticks_frequency)
  ax.set_xticks(x_ticks[x_ticks != 0])
  ax.set_yticks(y_ticks[y_ticks != 0])
  # Creamos las marcas menores colocadas en cada entero para habilitar el dibujo de
  # las líneas de cuadrícula menores: tenga en cuenta que esto no tiene efecto en
  ax.set_xticks(np.arange(xmin, xmax+1), minor=True)
  ax.set_yticks(np.arange(ymin, ymax+1), minor=True)
  # Dibujamos las lineas de la cuadrícula
  ax.grid(which='both', color='grey', linewidth=1, linestyle='-', alpha=0.2)
  # Dibujamos las flechas
  arrow_fmt = dict(markersize=4, color='black', clip_on=False)
  ax.plot((1), (0), marker='>', transform=ax.get_yaxis_transform(), **arrow_fmt)
  ax.plot((0), (1), marker='^', transform=ax.get_xaxis_transform(), **arrow_fmt)

def zoom(figOrAx,limites):

  """
  input:
        figOrAx: figura o ejes que se utilizarán como referencia para la copia
        limites: formato de entrada en el que pueden faltar algun componente de los cuatro valores [[-x,x],[-y,y]].
  output:
        cx: devuelve la ventana en la que se ha dibujado
  """

  xmin,xmax,ymin,ymax=ajustarLimites(limites)

  if type(figOrAx)==matplotlib.figure.Figure:
    fig2=copy.deepcopy(figOrAx)
    cx = fig2.get_axes()[0]
  elif type(figOrAx)==matplotlib.axes._axes.Axes:
    cx=copy.deepcopy(figOrAx)

  cx.set_xlim(xmin, xmax)  # Set the x-axis limits
  cx.set_ylim(ymin, ymax)  # Set the y-axis limits
  return cx

def dibujarPolosCeros(ax,limites,TF,tono=1.0):
  #REVISAR EDUARDO#
  """
  input:
        ax: ventana donde se dibujará la imagen.
        limites: formato de entrada en el que pueden faltar algun componente de los cuatro valores [[-x,x],[-y,y]].
        TF: función de transferencia.
  output:

  código:
        ceros,polos,gain=InfoTF("ceros_polos",TF)

        for i in range(len(polos)) :
          ax.scatter(polos[i].real, polos[i].imag, s=200,c='r', marker="x")
        for j in range(len(ceros)) :
          ax.scatter(ceros[j].real, ceros[j].imag, s=200,c='b', marker="o")
  """

  xmin,xmax,ymin,ymax=ajustarLimites(limites)
  ax.set_xlim(xmin, xmax)
  ax.set_ylim(ymin, ymax)

  TF=forzarTFControl(TF)


  ceros,polos,gain=InfoTF("ceros_polos",TF)

  for i in range(len(polos)) :
    ax.scatter(polos[i].real, polos[i].imag, s=200,color=(tono, 0, 0), marker="x")
  for j in range(len(ceros)) :
    ax.scatter(ceros[j].real, ceros[j].imag, s=200,color=(0, 0, tono), marker="o")

def polosDominantes(TF, polo):
  """
  input:
        TF: función de transferencia.
  output:
        DominanteONoDominante: True o False depenendiendo de si es o no dominante el polo evaluado
  código:
        ceros,polos,gain=InfoTF("ceros_polos",TF)

        # Verificar si hay un cero cercano al polo
        for c in ceros:
            if abs(polo - c) < 0.01:  # Ajusta el valor de tolerancia según sea necesario
                return False

        # Encontrar el polo de baja frecuencia más cercano
        min_low_freq_pole = min(polos, key=lambda p: abs(p - 0j))

        # Verificar si la parte real del polo es al menos 10 veces mayor que la parte real del polo de baja frecuencia más cercano
        if polo.real >= 10 * min_low_freq_pole.real:
            return True

        return False
  """
  TF=forzarTFControl(TF)
  ceros,polos,gain=InfoTF("ceros_polos",TF)

  # Encontrar el polo de baja frecuencia más cercano
  min_low_freq_pole = min(polos, key=lambda p: abs(p - 0j))

  # Verificar si hay un cero cercano al polo
  for c in ceros:
      if abs(polo - c) < (1/6)*abs(min_low_freq_pole.real):  # Ajusta el valor de tolerancia según sea necesario
          return False

  # Verificar si la parte real del polo es al menos 10 veces mayor que la parte real del polo de baja frecuencia más cercano
  if abs(polo.real)<=6*abs(min_low_freq_pole.real):
      return True

  return False

def eliminarPolosCeros(TF):
  ceros,polos,gain=InfoTF("ceros_polos",TF)

  # Encontrar el polo de baja frecuencia más cercano
  min_low_freq_pole = min(polos, key=lambda p: abs(p - 0j))

  # Verificar si hay un cero cercano al polo
  cerosc=[]
  polosc=[]
  for c in ceros:
    ceroCancelado=0
    for p in polos:
      if abs(p - c) < (1/6)*abs(min_low_freq_pole.real):  # Ajusta el valor de tolerancia según sea necesario
        if ceroCancelado==0:
          polosc.append(p)
        ceroCancelado=1
    if ceroCancelado==1:
      cerosc.append(c)

  ceroscopy=copy.deepcopy(ceros)
  poloscopy=copy.deepcopy(polos)
  for cc in ceroscopy:
    if cc in cerosc:
      ceros.remove(cc)
  for pc in poloscopy:
    if pc in polosc:
      polos.remove(pc)

  # Verificar si la parte real del polo es al menos 10 veces mayor que la parte real del polo de baja frecuencia más cercano
  for pl in polos:
    if abs(pl.real)>=6*abs(min_low_freq_pole.real):
      polos.remove(pl)

  TFSimplified=generarTF("ceros_polos",ceros,polos)
  return TFSimplified

def regimenPermanente(G,H,VectorError):
  """
  input:
        TF: función de transferencia.
        VectorError: puede ser errP para el error y constante de posición,  errV para el error y constante de velocidad y errA para el error y constante de acceleración. Se pueden combinar en el vector.
  output:
        VectorErrorReturn: vector que contiene tuplas de los errores de posición, velocidad y acceleración.

        [kp: constante del error de posición , ep: error de posición en régimen permanente]
        [kv: constante del error de velocidad , ev: error de velocidad en régimen permanente]
        [ka: constante del derror de acceleración ,ea: error de acceleración en régimen permanente]

  código:
        s = sympy.Symbol('s')

        #Forzar libreria sympy
        num,den,gain=InfoTF("num_den",G)
        numcK=[]
        for i in num:
          numcK.append(float(i)*gain)
        num=generarTF("num_den",numcK,[1],1)
        den=generarTF("num_den",den,[1],1)
        G=num/den
        #Forzar libreria sympy

        #Forzar libreria sympy
        num,den,gain=InfoTF("num_den",H)
        numcK=[]
        for i in num:
          numcK.append(float(i)*gain)
        num=generarTF("num_den",numcK,[1],1)
        den=generarTF("num_den",den,[1],1)
        H=num/den
        #Forzar libreria sympy

        Mp=G*H
        Mv=s*G*H
        Ma=s*s*G*H

        VectorErrorReturn=[]

        kp=Mp.subs(s, 0),
        ep=1/(1+Mp.subs(s, 0))
        if VectorError.count("errP") > 0:
          VectorErrorReturn.append([kp,ep])

        kv=Mv.subs(s, 0),
        ev=1/(Mv.subs(s, 0))
        if VectorError.count("errV") > 0:
          VectorErrorReturn.append([kv,ev])

        ka=Ma.subs(s, 0)
        ea=1/(Ma.subs(s, 0))
        if VectorError.count("errA") > 0:
          VectorErrorReturn.append([ka,ea])

        return  VectorErrorReturn
  """
  s = sympy.Symbol('s')

  G=forzarTFSympy(G)
  H=forzarTFSympy(H)

  Mp=G*H
  Mv=s*G*H
  Ma=s*s*G*H

  VectorErrorReturn=[]

  kp=Mp.subs(s, 0),
  ep=100*(1/(1+Mp.subs(s, 0)))
  if VectorError.count("errP") > 0:
    VectorErrorReturn.append([kp,ep])

  kv=Mv.subs(s, 0),
  ev=100*(1/(Mv.subs(s, 0)))
  if VectorError.count("errV") > 0:
    VectorErrorReturn.append([kv,ev])

  ka=Ma.subs(s, 0)
  ea=100*(1/(Ma.subs(s, 0)))
  if VectorError.count("errA") > 0:
    VectorErrorReturn.append([ka,ea])

  return  VectorErrorReturn

def ajustarGanancia(TF1,TF2):
  s=sympy.symbols('s')
  K=sympy.symbols('K')

  TF1=forzarTFSympy(TF1)
  TF2=forzarTFSympy(TF2)

  Y1=s*(1/s)*TF1
  Y2=K*s*(1/s)*TF2

  K=sympy.solve((Y1.subs(s,0)/Y2.subs(s,0)-1),K)
  return K

def errCriterio(err,errPunto):
  """
  input:
        err: en porcentaje, restricción de error del sistema
        errPunto: en porcentaje, error del sistema para cierto punto
  output:
        True or False, si cumple o no
  código:
        if errp>errPunto:
          print("Cumple el criterio de regimen permanente")
          return True
        else
          print("No cumple el criterio de regimen permanente")
          return False
  """

  if err>errPunto:
    print("Cumple el criterio de regimen permanente")
    return True
  else:
    print("No cumple el criterio de regimen permanente")
    return False

def tipoRespuestaNorden(TF):

  """
  input:
        TF: función de transferencia.
  output:
        tipo: tipo del sistema de segundo orden.
            inestable=-1
            subamortiguado=0
            amortiguado=1
            sobreamortiguado=2
  código:
        ceros,polos,gain=InfoTF("ceros_polos",TF)
        if (polos[0].real and polos[1].real)==0:
          print('Sistema de 2do orden inestable')
          tipo=-1
        elif (polos[0].real == polos[1].real):
          print('Sistema de 2do orden subamortiguado')
          tipo=0
        elif polos[0]==polos[1]:
          print('Sistema de 2do orden críticamente amortiguado')
          tipo=1
        else:
          print('Sistema de 2do orden sobreamortiguado')
          tipo=2
        return tipo
  """

  TF=forzarTFControl(TF)

  ceros,polos,gain=InfoTF("ceros_polos",TF)
  if ordenTF(TF)==2:
    if estabilidadTF(TF)==0:
      print('Sistema de 2do orden inestable')
      tipo=-1
    elif (polos[0].real == polos[1].real):
      print('Sistema de 2do orden subamortiguado (polo conjugado)')
      tipo=0
    elif polos[0]==polos[1]:
      print('Sistema de 2do orden críticamente amortiguado (polo real doble igual)')
      tipo=1
    else:
      print('Sistema de 2do orden sobreamortiguado (polos reales distintos)')
      tipo=2
  elif ordenTF(TF)>2:
    t,y=control.step_response(TF,20)
    b=y[len(t)-1]
    a=max(y)-b
    #if (a/b)*100>0.05:
    if estabilidadTF(TF)==0:
      print('Sistema de orden superior a 2, tipo inestable')
      tipo=-1
    else:
      if any(abs(pole.imag) > 0.05 for pole in polos):
        print('Sistema de orden superior a 2, tipo subamortiguado')
        tipo=0
      else:
        if len(set(polos)) == 1:
          print('Sistema de orden superior a 2, tipo  críticamente amortiguado')
          tipo=1
        else:
          print('Sistema de orden superior a 2, tipo  sobreamortiguado')
          tipo=2
  else:
      print('Sistema de 1er orden')
      tipo=None

  return tipo

def parameterMp(Mp):

  """
  input:
        Mp: especificación de las restricciones del sistema, sobreoscilación.
  output:
        theta: devuelve el valor que limita la zona valida, según las restricciones.

  código:
        if Mp!=None:
            Mp=Mp/100
            theta=np.arctan(-math.pi/np.log(Mp))
        return theta
  """

  if Mp!=None:
    Mp=Mp/100
    theta=np.arctan(-math.pi/np.log(Mp))
  return theta

def parameterTp(Tp):

  """
  input:
        Tp: especificación de las restricciones del sistema, tiempo de pico.
  output:
        wd: devuelve el valor que limita la zona valida, según las restricciones.

  código:
        if Tp!=None:
          wd=math.pi/Tp
        return wd
  """

  if Tp!=None:
    wd=math.pi/Tp
  return wd

def parameterTs(Ts):

  """
  input:
        Ts: especificación de las restricciones del sistema, tiempo de pico.
  output:
        sgm: devuelve el valor que limita la zona valida, según las restricciones.

  código:
        if Ts!=None:
          sgm=math.pi/Ts
        return sgm
  """

  if Ts!=None:
    sgm=math.pi/Ts
  return sgm

def dibujarRestriccionMp(ax,theta,limites):

  """
  input:
        ax: ventana donde se dibujará la imagen.
        theta: limite para las restricciones.
        limites: formato de entrada en el que pueden faltar algun componente de los cuatro valores [[-x,x],[-y,y]].
  output:
        x1: componente de los puntos X en los que se encuentran los limites de las restricciones.
        y1: componente de los puntos Y en los que se encuentran los limites de las restricciones.

  código:
        xmin,xmax,ymin,ymax=ajustarLimites(limites)

        if theta!=None:
          x1 = [-xmax * math.cos(theta), 0,0, -xmax * math.cos(theta)]
          y1 = [-ymax * math.sin(theta), 0,0,  ymax * math.sin(theta)]
        else:
          x1 = [-xmax,0,0,-xmax]
          y1 = [ymax,ymax,-ymax,-ymax]
        if ax!=None:
          ax.plot(x1, y1, c='brown', ls='--', lw=1, alpha=1)
          ax.fill(x1, y1, alpha=0.2, color='r', hatch='/')

        return x1,y1
  """

  xmin,xmax,ymin,ymax=ajustarLimites(limites)
  if ax!=None:
    ax.set(xlim=(xmin-1, xmax+1), ylim=(ymin-1, ymax+1))

  xmin=10000*xmin
  xmax=10000*xmax
  ymin=10000*ymin
  ymax=10000*ymax

  if theta!=None:
    x1 = [-xmax * math.cos(theta), 0,0, -xmax * math.cos(theta)]
    y1 = [-ymax * math.sin(theta), 0,0,  ymax * math.sin(theta)]
  else:
    x1 = [-xmax,0,0,-xmax]
    y1 = [ymax,ymax,-ymax,-ymax]

  if ax!=None:
    ax.plot(x1, y1, c='brown', ls='--', lw=1, alpha=1)
    ax.fill(x1, y1, alpha=0.2, color='r', hatch='/')

  return x1,y1

def dibujarRestriccionTp(ax,wd,limites):

  """
  input:
        ax: ventana donde se dibujará la imagen.
        wd: limite para las restricciones.
        limites: formato de entrada en el que pueden faltar algun componente de los cuatro valores [[-x,x],[-y,y]].
  output:
        x21: componente de los puntos X en los que se encuentran los limites de las restricciones en Y+.
        y21: componente de los puntos Y en los que se encuentran los limites de las restricciones en Y+.
        x22: componente de los puntos X en los que se encuentran los limites de las restricciones en Y-.
        y22: componente de los puntos Y en los que se encuentran los limites de las restricciones en Y-.

  código:
        xmin,xmax,ymin,ymax=ajustarLimites(limites)

        if wd!=None:
          x21 = [0, 0, -xmax, -xmax]
          y21 = [ymax, wd, wd, ymax]
          x22 = [0, 0, -xmax, -xmax]
          y22 = [-ymax, -wd, -wd, -ymax]
        else:
          x21 = [-xmax,0,0,-xmax]
          y21 = [ymax,ymax,-ymax,-ymax]
          x22 = [-xmax,0,0,-xmax]
          y22 = [-ymax,-ymax,-ymax,-ymax]

        if ax!=None:
          ax.fill(x21,y21,alpha=0.3,color='green',hatch='|')
          ax.fill(x22,y22,alpha=0.3,color='green',hatch='|')
        return x21,y21,x22,y22
  """

  xmin,xmax,ymin,ymax=ajustarLimites(limites)
  if ax!=None:
    ax.set(xlim=(xmin-1, xmax+1), ylim=(ymin-1, ymax+1))

  xmin=10000*xmin
  xmax=10000*xmax
  ymin=10000*ymin
  ymax=10000*ymax

  if wd!=None:
    x21 = [0, 0, -xmax, -xmax]
    y21 = [ymax, wd, wd, ymax]
    x22 = [0, 0, -xmax, -xmax]
    y22 = [-ymax, -wd, -wd, -ymax]
  else:
    x21 = [-xmax,0,0,-xmax]
    y21 = [ymax,ymax,-ymax,-ymax]
    x22 = [-xmax,0,0,-xmax]
    y22 = [-ymax,-ymax,-ymax,-ymax]

  if ax!=None:
    ax.fill(x21,y21,alpha=0.3,color='green',hatch='-')
    ax.fill(x22,y22,alpha=0.3,color='green',hatch='-')

  return x21,y21,x22,y22

def dibujarRestriccionTs(ax,sigma,limites):

  """
  input:
        ax: ventana donde se dibujará la imagen.
        sigma: limite para las restricciones.
        limites: formato de entrada en el que pueden faltar algun componente de los cuatro valores [[-x,x],[-y,y]].
  output:
        x3: componente de los puntos X en los que se encuentran los limites de las restricciones.
        y3: componente de los puntos Y en los que se encuentran los limites de las restricciones.

  código:
        xmin,xmax,ymin,ymax=ajustarLimites(limites)

        if sigma!=None:
          x3= [-xmax,-sigma,-sigma,-xmax]
          y3= [ymax,ymax,-ymax,-ymax]
        else:
          x3= [-xmax,0,0,-xmax]
          y3= [ymax,ymax,-ymax,-ymax]
        if ax!=None:
          ax.fill(x3,y3,alpha=0.3,color='orange',hatch='|')
        return x3,y3
  """

  xmin,xmax,ymin,ymax=ajustarLimites(limites)
  if ax!=None:
    ax.set(xlim=(xmin-1, xmax+1), ylim=(ymin-1, ymax+1))

  xmin=10000*xmin
  xmax=10000*xmax
  ymin=10000*ymin
  ymax=10000*ymax

  if sigma!=None:
    x3= [-xmax,-sigma,-sigma,-xmax]
    y3= [ymax,ymax,-ymax,-ymax]
  else:
    x3= [-xmax,0,0,-xmax]
    y3= [ymax,ymax,-ymax,-ymax]

  if ax!=None:
    ax.fill(x3,y3,alpha=0.3,color='orange',hatch='|')

  return x3,y3

def parametrosRespuestaTemporal(ax,valores,tiempo):

  """
  input:
        ax: ventana donde se dibujará la imagen.
        valores: valor de puesta temporal en el eje Y del sistema de transferencia.
        tiempo: vector temporal de la respuesta temporal en el eje X del sistema de transferencia.
  output:

  código:
        t=tiempo
        y=valores

        b=y[len(t)-1]
        a=max(y)-b
        errp=1-y[len(t)-1]


        ax.plot([0, 0], [0, y[len(t)-1]], c='green', ls='--', lw=1, alpha=1)
        ax.annotate('b=%s'%round(b,3),(0,b/2),(0,b/2))
        ax.plot([0, 0], [y[len(t)-1], max(y)], c='blue', ls='--', lw=1, alpha=1)
        ax.annotate('a=%s'%round(a,3),(0,b+a/2),(0,b+a/2))
        ax.annotate('a+b=%s'%round(a+b,3),(0,b+a),(0,b+a))
        ax.annotate('vf=%s'%round(b,3),(t[len(t)-1],b),(t[len(t)-1],b))

        print("Sobreoscilacion: ",100*(a/b),"%")
        print("Errp: ",errp)
        print("b: ",b)
        print("a: ",a)
        print("valor final: ",b)
        print("max: ",a+b)
        if a>0:

          tp=t[np.argmax(y)]
          print("tp: ",tp,"s")
          ax.annotate('tp=%s s'%round(tp,3),(tp,0.1),(tp,0.1))
          ax.plot([0, tp], [y[len(t)-1], y[len(t)-1]], c='red', ls='--', lw=1, alpha=1)
          ax.plot([0, tp], [a+b, a+b], c='b', ls='--', lw=1, alpha=1)
          ax.plot([tp, tp], [0, y[np.argmax(y)]], c='red', ls='--', lw=1, alpha=1)
          ax.plot([tp, t[len(t)-1]], [y[len(t)-1], y[len(t)-1]], c='black', ls='--', lw=1, alpha=1)
        else:
          pto_y=0.632*np.max(y)
          round_pto_y=round(pto_y,5)
          round_K=round(np.max(y),5)
          for i in range(len(y)):
            if pto_y-y[i]<0:
              ts=t[i-1]
              break
          ax.annotate('T=%s s'%round(ts,3),(ts,pto_y-0.1),(ts,pto_y-0.1))
  """

  t=tiempo
  y=valores

  b=y[len(t)-1]
  a=max(y)-b
  errp=1-y[len(t)-1]

  ax.set(xlim=(-6.5, t[len(t)-1]+0.2), ylim=(-0.2, max(y)+0.2))

  ax.plot([0, 0], [0, y[len(t)-1]], c='green', ls='--', lw=1, alpha=1)
  ax.annotate('b=%s'%round(b,3),(0,b/2),(0,b/2))
  ax.annotate('vf=%s'%round(b,3),(t[len(t)-1],b),(t[len(t)-1],b))


  print("Errp: ",errp)
  print("valor final: ",b)


  if (a/b)*100>2:
    ax.plot([0, 0], [y[len(t)-1], max(y)], c='blue', ls='--', lw=1, alpha=1)
    ax.annotate('a=%s'%round(a,3),(0,b+a/2),(0,b+a/2))
    ax.annotate('a+b=%s'%round(a+b,3),(-6,(b+a)/2),(-6,(b+a)/2))
    ax.annotate('Mp=%s%%'%round((a/b)*100),(-6,((b+a)/2)-0.3),(-6,((b+a)/2)-0.3))

    print("Sobreoscilacion: ",100*(a/b),"%")
    print("b: ",b)
    print("a: ",a)
    print("Mp: ",(a/b)*100)
    print("max: ",a+b)

    tp=t[np.argmax(y)]
    print("tp: ",tp,"s")

    tr=[]
    ytr=[]
    vfind=y[len(t)-1]
    for i in range(len(y)):
      if vfind-y[i]<0:
        tr=t[i-1]
        ytr=y[i]
        break

    ax.annotate('tp=%s s'%round(tp,3),(tp,0.1),(tp,0.1))
    ax.annotate('tr=%s s'%round(tr,3),(tr,-0.1),(tr,-0.1))
    ax.plot([tr, tr], [0, ytr], c='green', ls='--', lw=1, alpha=1)
    ax.plot([0, tp], [y[len(t)-1], y[len(t)-1]], c='red', ls='--', lw=1, alpha=1)
    ax.plot([0, tp], [a+b, a+b], c='b', ls='--', lw=1, alpha=1)
    ax.plot([tp, tp], [0, y[np.argmax(y)]], c='green', ls='--', lw=1, alpha=1)
    ax.plot([tp, t[len(t)-1]], [y[len(t)-1], y[len(t)-1]], c='black', ls='--', lw=1, alpha=1)

  elif (y[1] - y[0]) / (t[1] - t[0])>0.05:
    #EDUARDO!!!, ESTA CONDICION ES PORQUE ES SOLO PARA PRIMER ORDEN
    pto_y=0.632*np.max(y)
    round_pto_y=round(pto_y,5)
    round_K=round(np.max(y),5)
    for i in range(len(y)):
      if pto_y-y[i]<0:
        T=t[i-1]
        break
    ax.plot([0, T], [0, np.max(y)], c='y', ls='--', lw=1, alpha=1)
    ax.annotate('/=%s'%round(np.max(y)/T,3),(-5,np.max(y)/2),(-5,np.max(y)/2))
    ax.plot([0, T], [pto_y, pto_y], c='r', ls='--', lw=1, alpha=1)
    ax.plot([T, T], [0, pto_y], c='g', ls='--', lw=1, alpha=1)
    ax.annotate('T=%s s'%round(T,3),(T,pto_y-0.1),(T,pto_y-0.1))

def parametrosTipoRegimen(ax,y,t):


  """
  input:
        y: valores de la señal para la respuesta en regimen permanente
        t: vector de tiempos correspondiente a los valores de la señal en regimen permanente
  output:

  código:
        fv=y[len(t)-1]

        max5fv=fv+fv*(5/100)
        min5fv=fv-fv*(5/100)

        rp=[]
        yp=[]
        pto_y=max5fv
        for i in range(len(y)):
          if pto_y-y[i]<0:
            rp=t[i-1]
            yp=pto_y
            break
        if rp!=None:
          pto_y=min5fv
          for i in range(len(y)):
            if pto_y-y[i]<0:
              rp=t[i-1]
              yp=pto_y
              break

        ax.plot([rp, rp], [0, yp], c='green', ls='--', lw=1, alpha=1)
        ax.plot([0, rp], [yp, yp], c='red', ls='--', lw=1, alpha=1)
        ax.plot([rp, len(t)], [yp, yp], c='blue', ls='--', lw=1, alpha=1)
        ax.annotate('Régimen \n transitorio',(rp/2,yp-0.1),(rp/2,yp-0.1))
        ax.annotate('Régimen \n permanente',(t[len(t)-1]/2,yp-0.1),(t[len(t)-1]/2,yp-0.1))
  """

  fv=y[len(t)-1]

  max5fv=fv+fv*(5/100)
  min5fv=fv-fv*(5/100)

  rp=[]
  yp=[]
  pto_ymax=max5fv
  pto_ymin=min5fv
  for i in range(len(y)-1,1,-1):
    if pto_ymax-y[i]<0:
      rp=t[i-1]
      yp=pto_ymax
      break
    if y[i]<=pto_ymin:
      rp=t[i-1]
      yp=pto_ymin
      break

  ax.plot([rp, rp], [0, yp], c='green', ls='--', lw=1, alpha=1)
  ax.annotate('Ts=%s s'%round(rp,3),(rp,0.3),(rp,0.3))
  ax.plot([0, rp], [yp, yp], c='red', ls='--', lw=1, alpha=1)
  ax.plot([rp, t[len(t)-1]], [yp, yp], c='blue', ls='--', lw=1, alpha=1)
  ax.annotate('Régimen \n transitorio',(rp/2,yp-0.1),(rp/2,yp-0.1))
  ax.annotate('Régimen \n permanente',(t[len(t)-1]/2,yp-0.1),(t[len(t)-1]/2,yp-0.1))

def parametrosTipoRegimenVideo(y,t,limites):

  global axs
  global figs
  global ys
  global ts


  fig = plt.figure(figsize = (5,5))
  ax = fig.add_subplot(1,1,1)

  xmin,xmax,ymin,ymax=ajustarLimites(limites)

  ax.set(xlim=(xmin-1, xmax+1), ylim=(ymin-1, ymax+1))

  fv=y[len(t)-1]

  max5fv=fv+fv*(5/100)
  min5fv=fv-fv*(5/100)

  rp=[]
  yp=[]
  ts=[]
  ys=[]
  pto_ymax=max5fv
  pto_ymin=min5fv
  for i in range(len(y)-1,1,-1):
    ys.append(y[i-1])
    ts.append(t[i-1])
    if pto_ymax-y[i]<0:
      rp=t[i-1]
      yp=pto_ymax
      break
    if y[i]<=pto_ymin:
      rp=t[i-1]
      yp=pto_ymin
      break
  ax.plot([rp, rp], [0, yp], c='green', ls='--', lw=1, alpha=1)
  ax.annotate('Ts=%s s'%round(rp,3),(rp,0.3),(rp,0.3))
  ax.plot([0, rp], [yp, yp], c='red', ls='--', lw=1, alpha=1)
  ax.plot([rp, t[len(t)-1]], [yp, yp], c='blue', ls='--', lw=1, alpha=1)
  ax.annotate('Régimen \n transitorio',(rp/2,yp-0.1),(rp/2,yp-0.1))
  ax.annotate('Régimen \n permanente',(t[len(t)-1]/2,yp-0.1),(t[len(t)-1]/2,yp-0.1))

  axs=ax
  figs=fig

  #ys=ys.reverse()
  #ts=ts.reverse()
  ani = FuncAnimation(fig, updateScatterTipoRegimen, frames=len(ys), interval=0.00000000000000001, repeat=False)
  return HTML(ani.to_jshtml())
def updateScatterTipoRegimen(frame):
  global axs
  global figs
  global ys
  global ts
  axs.scatter(ts[frame],ys[frame],s=7,c='r', marker="o")

def errorRegimenPermanenteVisualizacion(ax,y,t):

  for i in np.arange(0,len(t),2):
    if i<1:
      ax.plot([t[i], t[i]], [1, y[i]], c='red', ls='--', lw=1, alpha=1)
    elif i>1:
      ax.plot([t[i], t[i]], [y[i],1], c='red', ls='--', lw=1, alpha=1)

  ax.plot([t[len(t)-1], t[len(t)-1]], [1, y[len(y)-1]], c='green', ls='--', lw=1, alpha=1)

  ax.annotate('err=%s'%round((1-y[len(y)-1])*100,3),(t[len(t)-1],y[len(y)-1]+(1-y[len(y)-1])/2),(t[len(t)-1],y[len(y)-1]+(1-y[len(y)-1])/2))