# -*- coding: utf-8 -*-
"""simphysiclab_sistemas.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YiQ-cPUXQ_8TW0ANa1E60WqKIvHAwRsh

# <font color="darkorange">Librería SISTEMAS de SIMPHYSICLAB</font>

**Autoría**:

*   Eduardo Iáñez (eianez@umh.es)
*   Vicente Quiles (vquiles@umh.es)
*   Federico Botella (federico@umh.es)

Departamento de Ingeniería de Sistemas y Automática.

Universidad Miguel Hernández de Elche.


**Financiación**: El material que aparece a continuación se ha desarrollado dentro del marco del proyecto UNIDIGITAL- SIMPHYSICLAB.

<small><img src=https://raw.githubusercontent.com/SIMPHYSICLAB/simphysiclab/main/images/logo_unidigital_simphysiclab.png></small>

**Fecha última edición**: 15/06/2023

**Licencia**: <small><a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" /></a><br /></small>

*No olvides hacer una copia si deseas utilizarlo. Al usar estos contenidos, aceptas nuestros términos de uso y nuestra política de privacidad.*

### <font color="darkorange">Introducción</font>

En este fichero .py pueden encontrarse todas las funciones desarrolladas para la librería SISTEMAS dentro del proyecto SIMPHYSICLAB. No es por tanto un cuaderno al uso sino que será cargado en cada cuaderno del proyecto para poder utilizar dichas funciones.

**Las funciones están relacionadas con ...**

### <font color="darkorange">Librerias de python necesarias para el funcionamiento de las funciones</font>
"""

# Commented out IPython magic to ensure Python compatibility.
#Standard Python libraries:
import math
import random
import time
import copy
import numpy as np

#Specific control system python libraries:
import control
import sympy
from tbcontrol.symbolic import routh

#Plot python graphic libraries and interactive
import matplotlib
# %matplotlib ipympl
sympy.init_printing()
import matplotlib.pyplot as plt
import matplotlib.path as mpath
import matplotlib.colors as colors

from google.colab import output
output.enable_custom_widget_manager()
import ipywidgets as widgets

"""### <font color="darkorange">Funciones para la generación y representación del sistema</font>

### <font color="darkorange">Funciones auxiliares</font>
"""

def tipoLibreria(TF):
  '''
  input:
        TF: función de transferencia.
  output:
        libreria: nombre de la librería principal de la función de transferencia.
  código:
        def tipoLibreria(TF):
          libreria=type(TF).__module__.split('.')[0]
          return libreria
  '''
  libreria=type(TF).__module__.split('.')[0]
  return libreria

def parametrosLibreriaEnTF(TF):
  '''
  input:
        TF: función de transferencia.
  output:
        libreria: nombre de la librería si TF tubiera algun parametro.
  código:
        if tipoLibreria(TF)=="sympy":
          symbolappearance=[]
          num,den,gain=InfoTF("num_den",TF)
          return parametrosLibereriaEnPol(num,den)
        else:
          return "other"
  '''

  if tipoLibreria(TF)=="sympy":
    symbolappearance=[]
    num,den,gain=InfoTF("num_den",TF)
    return parametrosLibereriaEnPol(num,den)
  else:
    return "other"

def parametrosLibereriaEnPol(num,den):
  '''
  input:
        num: numerador de TF
        den: denominador de TF
  output:
        libreria: nombre de la librería si num or den tubieran algun parametro.
  código:
        symbolappearance=[]
        for i in np.concatenate((num, den), axis=0):
            try:
              testrealnumber=float(i)
              symbolappearance.append(0)
            except:
              symbolappearance.append(1)
        if symbolappearance.count(1)>0:
          return "sympy"
        else:
          return "other"
  '''
  symbolappearance=[]
  for i in np.concatenate((num, den), axis=0):
      try:
        testrealnumber=float(i)
        symbolappearance.append(0)
      except:
        symbolappearance.append(1)
  if symbolappearance.count(1)>0:
    return "sympy"
  else:
    return "other"

#Crear funcion de transfercia generica ya sea G o H
def generarTF(tipo,num,den,simbol=0):
  '''
    input:
          G: función de transferencia G.
          H: función de transferencia H.
          k: valor de retroalimentación k, que puede ser simbólico o noo.
    output:
          M: función retroalimentada.
    código:
          if tipo=="num_den":
            symbolappearance=[]
            #Comprobar si contiene algun simbolico la expresión
            for i in np.concatenate((num, den), axis=0):
              try:
                testrealnumber=float(i)
                symbolappearance.append(0)
              except:
                symbolappearance.append(1)

            #Contiene simbolicos#La expresión simbolica no se puede simplificar
            if (symbolappearance.count(1)!=len(np.concatenate((num, den), axis=0)) and symbolappearance.count(1)>0) or (simbol==1):
              s = sympy.Symbol('s')
              return sympy.factor(sympy.simplify(sympy.Poly(num, s)/sympy.Poly(den, s)))
            #Contiene simbolicos#Se puede simplificar la expresión simbolica
            elif symbolappearance.count(1)==len(np.concatenate((num, den), axis=0)) and symbolappearance.count(1)>0:
              numwithoutParameter=[]
              denwithoutParameter=[]
              for i in num:
                if len(i.atoms(sympy.Number))==0:
                  numwithoutParameter.append(float(1))
                else:
                  numwithoutParameter.append(float(i.atoms(sympy.Number).pop()))
              for i in den:
                if len(i.atoms(sympy.Number))==0:
                  denwithoutParameter.append(float(1))
                else:
                  denwithoutParameter.append(float(i.atoms(sympy.Number).pop()))

              return control.tf(numwithoutParameter, denwithoutParameter)
            #No contiene simbolicos
            else:
              #Este cast es por si simpy guarda los valores en un formato distinto de float
              numcastfloat=[]
              dencastfloat=[]
              for i in num:
                numcastfloat.append(float(i))
              for i in den:
                dencastfloat.append(float(i))
              #Crear la función de transferencia con los valores guardados en formato float
              return control.tf(numcastfloat, dencastfloat)
          elif tipo =="ceros_polos":
            if parametrosLibereriaEnPol(num,den)=="sympy":
              print("Error")
              return "Error."
            else:
              if simbol==0:
                s = control.tf('s')
                numcp = 1
                dencp = 1
                if len(num)==0 and len(den)==0:
                  TF=control.tf(1, 1)
                else:
                  for i in range(len(num)):
                    numcp = numcp * (s - num[i])
                  for j in range(len(den)):
                    dencp = dencp * (s - den[j])
                  TF=numcp/dencp
              elif simbol==1:
                s=sympy.symbols('s')
                numcp = 1
                dencp = 1
                if len(num)==0 and len(den)==0:
                  TF=sympy.factor(numcp/dencp)
                else:
                  for i in range(len(num)):
                    numcp = numcp * (s - num[i])
                  for j in range(len(den)):
                    dencp = dencp * (s - den[j])
                  TF=sympy.factor(numcp/dencp)

            return TF
  '''
  if tipo=="num_den":
    symbolappearance=[]
    #Comprobar si contiene algun simbolico la expresión
    for i in np.concatenate((num, den), axis=0):
      try:
        testrealnumber=float(i)
        symbolappearance.append(0)
      except:
        symbolappearance.append(1)

    #Contiene simbolicos#La expresión simbolica no se puede simplificar
    if (symbolappearance.count(1)!=len(np.concatenate((num, den), axis=0)) and symbolappearance.count(1)>0) or (simbol==1):
      s = sympy.Symbol('s')
      return sympy.factor(sympy.simplify(sympy.Poly(num, s)/sympy.Poly(den, s)))
    #Contiene simbolicos#Se puede simplificar la expresión simbolica
    elif symbolappearance.count(1)==len(np.concatenate((num, den), axis=0)) and symbolappearance.count(1)>0:
      numwithoutParameter=[]
      denwithoutParameter=[]
      for i in num:
        if len(i.atoms(sympy.Number))==0:
          numwithoutParameter.append(float(1))
        else:
          numwithoutParameter.append(float(i.atoms(sympy.Number).pop()))
      for i in den:
        if len(i.atoms(sympy.Number))==0:
          denwithoutParameter.append(float(1))
        else:
          denwithoutParameter.append(float(i.atoms(sympy.Number).pop()))

      return control.tf(numwithoutParameter, denwithoutParameter)
    #No contiene simbolicos
    else:
      #Este cast es por si simpy guarda los valores en un formato distinto de float
      numcastfloat=[]
      dencastfloat=[]
      for i in num:
        numcastfloat.append(float(i))
      for i in den:
        dencastfloat.append(float(i))
      #Crear la función de transferencia con los valores guardados en formato float
      return control.tf(numcastfloat, dencastfloat)
  elif tipo =="ceros_polos":
    if parametrosLibereriaEnPol(num,den)=="sympy":
      s=sympy.symbols('s')
      numcp = 1
      dencp = 1
      if len(num)==0 and len(den)==0:
        TF=sympy.factor(numcp/dencp)
      else:
        for i in range(len(num)):
          numcp = numcp * (s - num[i])
        for j in range(len(den)):
          dencp = dencp * (s - den[j])
        TF=sympy.factor(numcp/dencp)
    else:
      if simbol==0:
        s = control.tf('s')
        numcp = 1
        dencp = 1
        if len(num)==0 and len(den)==0:
          TF=control.tf(1, 1)
        else:
          for i in range(len(num)):
            numcp = numcp * (s - num[i])
          for j in range(len(den)):
            dencp = dencp * (s - den[j])
          TF=numcp/dencp
      elif simbol==1:
        s=sympy.symbols('s')
        numcp = 1
        dencp = 1
        if len(num)==0 and len(den)==0:
          TF=sympy.factor(numcp/dencp)
        else:
          for i in range(len(num)):
            numcp = numcp * (s - num[i])
          for j in range(len(den)):
            dencp = dencp * (s - den[j])
          TF=sympy.factor(numcp/dencp)

    return TF

def devolverPolos_Ceros(polosCeros):
    pole_values = list(polosCeros.keys())
    multiplicities = list(polosCeros.values())

    all_poles = []
    for i in range(len(pole_values)):
        current_pole = pole_values[i]
        current_multiplicity = multiplicities[i]
        all_poles.extend([current_pole] * current_multiplicity)

    return all_poles

def InfoTF(tipo,TF):

    '''
    input:
          G: función de transferencia G.
          H: función de transferencia H.
          k: valor de retroalimentación k, que puede ser simbólico o noo.
    output:
          M: función retroalimentada.
    código:
          if tipo=="num_den":
            num=[]
            den=[]

            if tipoLibreria(TF)=="sympy":
              n,d = sympy.fraction(TF)
              num=sympy.Poly(n, sympy.symbols('s')).all_coeffs()
              den=sympy.Poly(d, sympy.symbols('s')).all_coeffs()

              gain=num[0]
              denCoeff=den[0]

              numSimplify=[]
              denSimplify=[]

              for i in num:
                numSimplify.append(i/gain)
              for i in den:
                denSimplify.append(i)
              return numSimplify,denSimplify,gain
            else:

              gain=TF.num[0][0][0]

              for i in TF.num[0][0]:
                num.append(i.real/gain)
              for i in TF.den[0][0]:
                den.append(i.real)
              return num,den,gain
          elif tipo =="ceros_polos":
            if tipoLibreria(TF)=="sympy":
              n,d = sympy.fraction(TF)
              gain=sympy.Poly(n, sympy.symbols('s')).coeffs()[0]
              num=sympy.Poly(n, sympy.symbols('s'))
              den=sympy.Poly(d, sympy.symbols('s'))
              ceros=sympy.solve(num,sympy.symbols('s'))
              polos=sympy.solve(den,sympy.symbols('s'))
              return ceros,polos,gain
            else:
              gain=TF.num[0][0][0]
              ceros=TF.zeros()
              ceros=[np.round(i,8) for i in ceros]
              polos=TF.poles()
              polos=[np.round(i,8) for i in polos]
              return ceros,polos,gain
    '''
    if tipo=="num_den":
      num=[]
      den=[]

      if tipoLibreria(TF)=="sympy":
        n,d = sympy.fraction(TF)
        num=sympy.Poly(n, sympy.symbols('s')).all_coeffs()
        den=sympy.Poly(d, sympy.symbols('s')).all_coeffs()

        gain=num[0]
        denCoeff=den[0]

        numSimplify=[]
        denSimplify=[]

        for i in num:
          numSimplify.append(i/gain)
        for i in den:
          denSimplify.append(i)
        return numSimplify,denSimplify,gain
      else:

        gain=TF.num[0][0][0]

        for i in TF.num[0][0]:
          num.append(i.real/gain)
        for i in TF.den[0][0]:
          den.append(i.real)
        return num,den,gain
    elif tipo =="ceros_polos":
      if tipoLibreria(TF)=="sympy":
        n,d = sympy.fraction(TF)
        gain=sympy.Poly(n, sympy.symbols('s')).coeffs()[0]
        num=sympy.Poly(n, sympy.symbols('s'))
        den=sympy.Poly(d, sympy.symbols('s'))

        #ceros=sympy.solve(num,sympy.symbols('s'))
        ceros = devolverPolos_Ceros(sympy.roots(num,sympy.symbols('s')))
        #polos=sympy.solve(den,sympy.symbols('s'))
        polos = devolverPolos_Ceros(sympy.roots(den,sympy.symbols('s')))

        return ceros,polos,gain
      else:
        gain=TF.num[0][0][0]
        ceros=TF.zeros()
        ceros=[np.round(i,8) for i in ceros]
        polos=TF.poles()
        polos=[np.round(i,8) for i in polos]
        return ceros,polos,gain

def realimentacion(G,H,k=1):

    '''
      input:
            G: función de transferencia G.
            H: función de transferencia H.
            k: valor de retroalimentación k, que puede ser simbólico o noo.
      output:
            M: función retroalimentada.

      código:
            if (parametrosLibreriaEnTF(G)=="sympy" or parametrosLibreriaEnTF(H)=="sympy") and tipoLibreria(k)=="sympy":
              #print("1")
              num,den,gain=InfoTF("num_den",G)
              numk=[]
              for i in num:
                numk.append(i*k)
              G=gain*generarTF("num_den",numk,den)
              H,num,den,gain=InfoTF("num_den",H)
              H=gain*generarTF("num_den",num,den,1)
              M=(G/(1+(G*H)))
              M=sympy.simplify(M)
              return M
            elif (parametrosLibreriaEnTF(G)=="sympy" or parametrosLibreriaEnTF(H)=="sympy") and tipoLibreria(k)!="sympy":
              #print("2")
              num,den,gain=InfoTF("num_den",G)
              numk=[]
              for i in num:
                numk.append(i*k)
              G=gain*generarTF("num_den",numk,den,1)
              num,den,gain=InfoTF("num_den",H)
              H=gain*generarTF("num_den",num,den,1)
              M=(G/(1+(G*H)))
              M=sympy.simplify(M)
              return M
            elif (parametrosLibreriaEnTF(G)!="sympy" and parametrosLibreriaEnTF(H)!="sympy") and tipoLibreria(k)=="sympy":
              #print("3")
              num,den,gain=InfoTF("num_den",G)
              numk=[]
              for i in num:
                numk.append(i*k)
              G=gain*generarTF("num_den",numk,den,1)
              num,den,gain=InfoTF("num_den",H)
              H=gain*generarTF("num_den",num,den,1)
              M=(G/(1+(G*H)))
              M=sympy.simplify(M)
              return M
            elif (parametrosLibreriaEnTF(G)!="sympy" and parametrosLibreriaEnTF(H)!="sympy") and tipoLibreria(k)!="sympy":
              numG,denG,gainG=InfoTF("num_den",G)
              numH,denH,gainH=InfoTF("num_den",H)
              if tipoLibreria(G)=="sympy" and tipoLibreria(H)=="sympy":
                numk=[]
                for i in numG:
                  numk.append(i*k)
                G=gainG*generarTF("num_den",numk,denG,1)
                H=gainH*generarTF("num_den",numH,denH,1)
                M=((G)/(1+(G*H)))
                M=sympy.simplify(M)
              else:
                G=gainG*generarTF("num_den",numG,denG)
                H=gainH*generarTF("num_den",numH,denH)
                K_G=control.series(k,G)
                M=control.feedback(K_G,H)
                ceros,polos,gain=InfoTF("ceros_polos",M)
              return M
    '''

    if (parametrosLibreriaEnTF(G)=="sympy" or parametrosLibreriaEnTF(H)=="sympy") and tipoLibreria(k)=="sympy":
      #print("1")
      num,den,gain=InfoTF("num_den",G)
      numk=[]
      for i in num:
        numk.append(i*k)
      G=gain*generarTF("num_den",numk,den)
      H,num,den,gain=InfoTF("num_den",H)
      H=gain*generarTF("num_den",num,den,1)
      M=(G/(1+(G*H)))
      M=sympy.simplify(M)
      return M
    elif (parametrosLibreriaEnTF(G)=="sympy" or parametrosLibreriaEnTF(H)=="sympy") and tipoLibreria(k)!="sympy":
      #print("2")
      num,den,gain=InfoTF("num_den",G)
      numk=[]
      for i in num:
        numk.append(i*k)
      G=gain*generarTF("num_den",numk,den,1)
      num,den,gain=InfoTF("num_den",H)
      H=gain*generarTF("num_den",num,den,1)
      M=(G/(1+(G*H)))
      M=sympy.simplify(M)
      return M
    elif (parametrosLibreriaEnTF(G)!="sympy" and parametrosLibreriaEnTF(H)!="sympy") and tipoLibreria(k)=="sympy":
      #print("3")
      num,den,gain=InfoTF("num_den",G)
      numk=[]
      for i in num:
        numk.append(i*k)
      G=gain*generarTF("num_den",numk,den,1)
      num,den,gain=InfoTF("num_den",H)
      H=gain*generarTF("num_den",num,den,1)
      M=(G/(1+(G*H)))
      M=sympy.simplify(M)
      return M
    elif (parametrosLibreriaEnTF(G)!="sympy" and parametrosLibreriaEnTF(H)!="sympy") and tipoLibreria(k)!="sympy":
      numG,denG,gainG=InfoTF("num_den",G)
      numH,denH,gainH=InfoTF("num_den",H)
      if tipoLibreria(G)=="sympy" and tipoLibreria(H)=="sympy":
        numk=[]
        for i in numG:
          numk.append(i*k)
        G=gainG*generarTF("num_den",numk,denG,1)
        H=gainH*generarTF("num_den",numH,denH,1)
        M=((G)/(1+(G*H)))
        M=sympy.simplify(M)
      else:
        G=gainG*generarTF("num_den",numG,denG)
        H=gainH*generarTF("num_den",numH,denH)
        K_G=control.series(k,G)
        M=control.feedback(K_G,H)
        ceros,polos,gain=InfoTF("ceros_polos",M)
      return M

def ordenTF(TF):

  '''
    input:
          TF: función de transferencia.
    output:
          orden:orden del denominador del polinomio.

    código:
          num,den,gain=InfoTF("num_den",TF)
          orden=len(den)-1
          return orden
  '''

  num,den,gain=InfoTF("num_den",TF)
  orden=len(den)-1
  return orden

def inversaLaplace(TF,positivos):

  '''
    input:
          TF: función de transferencia.
          positivos: restingir a evaluar solo valors positivos
    output:
          inverse_laplace_transform: devuelve la transformada inversa de laplace

    código:
          #Forzar libreria sympy
          num,den,gain=InfoTF("num_den",TF)

          numcK=[]
          for i in num:
            numcK.append(float(i)*gain)
          denc=[]
          for i in den:
            denc.append(float(i))
          TF=generarTF("num_den",numcK,denc,1)
          #Forzar libreria sympy

          if positivos==1:
            s = sympy.symbols('s')
            t = sympy.Symbol('t', positive=True)
          else:
            s = sympy.symbols('s')
            t = sympy.Symbol('t')
          return sympy.inverse_laplace_transform(TF, s, t)
  '''

  #Forzar libreria sympy
  num,den,gain=InfoTF("num_den",TF)

  numcK=[]
  for i in num:
    numcK.append(i*gain)
  denc=[]
  for i in den:
    denc.append(i)
  TF=generarTF("num_den",numcK,denc,1)
  #Forzar libreria sympy

  if positivos==1:
    s = sympy.symbols('s')
    t = sympy.Symbol('t',  real=True,positive=True)
  else:
    s = sympy.symbols('s')
    t = sympy.Symbol('t')
  return sympy.inverse_laplace_transform(TF, s, t),t

def estabilidadTF(TF):

  '''
    input:
          TF: función de transferencia.
    output:

    código:
          if parametrosLibreriaEnTF(TF)=="sympy":
            print("La estabilidad con esta función solo se puede estudiar sin parametros variables.")
          else:
            ceros,polos,gain=InfoTF("ceros_polos",TF)
            ceros=[np.round(float(i),2) for i in ceros]
            polos=[np.round(float(i),2) for i in polos]
            EstableInestable=0
            for i in polos:
              if i.real>=0:
                if EstableInestable==0:
                  print("Sistema Inestable")
                  EstableInestable=1
                print("Polo inestable en:",i,", ")
            if EstableInestable==0:
              print("Sistema Estable")
  '''

  if parametrosLibreriaEnTF(TF)=="sympy":
    print("La estabilidad con esta función solo se puede estudiar sin parametros variables.")
  else:
    ceros,polos,gain=InfoTF("ceros_polos",TF)
    ceros=[np.round(float(i),2) for i in ceros]
    polos=[np.round(float(i),2) for i in polos]
    EstableInestable=0
    for i in polos:
      if i.real>=0:
        if EstableInestable==0:
          print("Sistema Inestable")
          EstableInestable=1
        print("Polo inestable en:",i,", ")
    if EstableInestable==0:
      print("Sistema Estable")
      return 1
    else:
      return 0

def estabilidadCardano(TF):

  '''
    input:
          TF: función de transferencia.
    output:

    código:
          num,den,gain=SIS.InfoTF("num_den",TF)

          coeffs = []
          for d in den:
            if d.atoms(sympy.Number)==set():
              coeffs.append(1)
            else:
              coeffs.append(d)

          has_zero = any(x == 0 for x in coeffs)
          if has_zero!=True:
            lastValue=np.sign(coeffs)
            indices = np.where(lastValue < 0)
            if len(indices)==0:
              print("Pasa los dos criterios de Cardano, se debe analizar la estabilidad según Ruth para asegurar Estabilidad.")
            else:
              print("Inestable. Falló el segundo criterio de Cardano.")
          else:
            print("Inestable. Falló el primer criterio de Cardano.")
  '''

  num,den,gain=InfoTF("num_den",TF)

  coeffs = []
  for d in den:
    if d.atoms(sympy.Number)==set():
      coeffs.append(1)
    else:
      coeffs.append(d)

  has_zero = any(x == 0 for x in coeffs)
  if has_zero!=True:
    lastValue=np.sign(coeffs)
    indices = np.where(lastValue < 0)
    if len(indices[0])==0:
      print("Cumple los dos criterios de Cardano, se debe analizar la estabilidad según Ruth para asegurar Estabilidad.")
    else:
      print("Inestable. No cumple el segundo criterio de Cardano.")
  else:
    print("Inestable. No cumple el primer criterio de Cardano.")

def estabilidadRouth(TF,simbolo=None):

  '''
    input:
          TF: función de transferencia.
          símbolo: símbolo a evaluar dentro de la función de transferencia.
    output:

    código:
          s = sympy.symbols('s')

          #Forzar libreria sympy
          num,den,gain=InfoTF("num_den",TF)
          #Forzar libreria sympy

          A = routh(sympy.Poly(den, s))

          print(A)

          zero_row_indices = [i for i, row in enumerate(A.tolist()) if all(element == 0 for element in row)]


          if any(zero_row_indices):
            print("fila de ceros")
          else:
            if parametrosLibereriaEnPol([1],den)=="sympy":
              for e in A[:, 0]:
                print("routh row: ",e)
                rowSolution=sympy.solve(e>0,simbolo)
                if rowSolution!=[]:
                  solution_set=rowSolution.as_set()
                  down_Limit = solution_set.args[0]
                  upper_Limit = solution_set.args[1]
                  print("row To row, Solution: ",rowSolution,down_Limit,upper_Limit)
              routhSolution=sympy.solve([e > 0 for e in A[:, 0]], simbolo)
              solution_set=routhSolution.as_set()
              down_Limit = solution_set.args[0]
              upper_Limit = solution_set.args[1]
              print("global, Solution:",routhSolution,down_Limit,upper_Limit)
            else:
              if any([e < 0 for e in A[:,0]]) and any([e != None for e in A[:,0]]):
                a=A[:,0]
                vector=np.transpose(a)
                lastValue=np.sign(vector[0])
                indices = np.where(lastValue < 0)
                print("inestable, cambios de signo en:",indices[0])
              else:
                print("estable")
  '''

  s = sympy.symbols('s')

  #Forzar libreria sympy
  num,den,gain=InfoTF("num_den",TF)
  #Forzar libreria sympy

  A = routh(sympy.Poly(den, s))

  print(A)

  zero_row_indices = [i for i, row in enumerate(A.tolist()) if all(element == 0 for element in row)]


  if any(zero_row_indices):
    print("fila de ceros")
  else:
    if parametrosLibereriaEnPol([1],den)=="sympy":
      for e in A[:, 0]:
        print("routh row: ",e)
        rowSolution=sympy.solve(e>0,simbolo)
        if rowSolution!=[]:
          solution_set=rowSolution.as_set()
          down_Limit = solution_set.args[0]
          upper_Limit = solution_set.args[1]
          print("row To row, Solution: ",rowSolution,down_Limit,upper_Limit)
      routhSolution=sympy.solve([e > 0 for e in A[:, 0]], simbolo)
      solution_set=routhSolution.as_set()
      down_Limit = solution_set.args[0]
      upper_Limit = solution_set.args[1]
      print("global, Solution:",routhSolution,down_Limit,upper_Limit)
    else:
      if any([e < 0 for e in A[:,0]]) and any([e != None for e in A[:,0]]):
        a=A[:,0]
        vector=np.transpose(a)
        lastValue=np.sign(vector[0])
        indices = np.where(lastValue < 0)
        print("inestable, cambios de signo en:",indices[0])
      else:
        print("estable")

def ecuacionCaracteristicaRouth(filaRouth,gradoPol,potencia):

  """
  input:
        filaRouth: lista de indices de la fila de la tabla de Routh.
        gradoPol: Grado del polinomio máximo.
        potencia: Grado del polinomio de la fila de Routh que se esta evaluando.
  output:
        C: indices arreglados del polinomio caracteristico extraido de la tabla de routh

  código:
        C=[]
        B=list(filaRouth)
        i=0
        longitud=gradoPol-potencia+2
        for x in range(1,longitud):f
          if x%2==0:
            C.append(0)
          else:
            C.append(B[i])
            i=i+1
        return C
  """

  C=[]
  B=list(filaRouth)
  i=0
  longitud=gradoPol-potencia+2
  for x in range(1,longitud):
    if x%2==0:
      C.append(0)
    else:
      C.append(B[i])
      i=i+1
  return C

def routhCasoEspecial(TF):

  '''
    input:
          TF: función de transferencia.
    output:
          A: Tabla de routh arreglada.

    código:
          #Forzar libreria sympy
          num,den,gain=InfoTF("num_den",TF)
          #Forzar libreria sympy

          pol=generarTF("num_den",den,[1],1)

          s = sympy.Symbol('s')
          coefsPar=coeficientesPares(pol)
          coefsImpar=coeficientesImpares(pol)
          A=np.zeros((len(pol), len(coefsPar)))
          for i in range(0,len(coefsPar)):
            A[0,i]=pol[(coefsPar[i])]
          for i in range(0,len(coefsImpar)):
            A[1,i]=pol[(coefsImpar[i])]
          for i in range(2,len(A[:,0])):
            for j in range(0,len(A[0,:])-1):
              A[i,j]=(-1/A[i-1,0])*np.linalg.det(np.array([[A[i-2,0], A[i-2,j+1]], [A[i-1,0], A[i-1,j+1]]]))
            if((np.count_nonzero(A[i,:] == 0)==len(coefsPar))==True):
              res=ecuacionCaracteristicaRouth(A[i-1,:],len(pol),(i))#ecuacionCaracteristicaRouth(A[i-1,:],len(pol),(i-1))
              ec=sympy.Poly(res, s)
              derivative = sympy.diff(ec, s)
              for pij in range(0,len(derivative.coeffs())):
                A[i,pij]=derivative.coeffs()[pij]
          return A

  '''

  #Forzar libreria sympy
  num,den,gain=InfoTF("num_den",TF)
  #Forzar libreria sympy

  #pol=generarTF("num_den",den,[1],1)
  pol=den

  s = sympy.Symbol('s')
  coefsPar=coeficientesPares(pol)
  coefsImpar=coeficientesImpares(pol)
  A=np.zeros((len(pol), len(coefsPar)))
  for i in range(0,len(coefsPar)):
    A[0,i]=pol[(coefsPar[i])]
  for i in range(0,len(coefsImpar)):
    A[1,i]=pol[(coefsImpar[i])]
  for i in range(2,len(A[:,0])):
    for j in range(0,len(A[0,:])-1):
      A[i,j]=(-1/A[i-1,0])*np.linalg.det(np.array([[A[i-2,0], A[i-2,j+1]], [A[i-1,0], A[i-1,j+1]]]))
    if((np.count_nonzero(A[i,:] == 0)==len(coefsPar))==True):
      res=ecuacionCaracteristicaRouth(A[i-1,:],len(pol),(i))#ecuacionCaracteristicaRouth(A[i-1,:],len(pol),(i-1))
      ec=sympy.Poly(res, s)
      derivative = sympy.diff(ec, s)
      for pij in range(0,len(derivative.coeffs())):
        A[i,pij]=derivative.coeffs()[pij]
  return A

def coeficientesPares(polinomio):

  '''
    input:
          polinomio: polinomio de la tabla de routh que se va a evaluar.
    output:
          polPar: Índices impares del polinomio.

    código:
          polPar=[]
          for i in range(0,len(polinomio), 2):
            polPar.append(i)
          return polPar
  '''

  polPar=[]
  for i in range(0,len(polinomio), 2):
    polPar.append(i)
  return polPar

def coeficientesImpares(polinomio):

  '''
    input:
          polinomio: polinomio de la tabla de routh que se va a evaluar.
    output:
          polImpar: Índices impares del polinomio.
    código:
          polImpar=[]
          for i in range(1,len(polinomio), 2):
            polImpar.append(i)
          return polImpar
  '''

  polImpar=[]
  for i in range(1,len(polinomio), 2):
    polImpar.append(i)
  return polImpar

def respuestaEscalon(ax,TF,tiempo):

  '''
    input:
          ax: ventana donde se dibujará la imagen.
          TF: función de transferencia.
          tiempo: tiempo máximo de la respuesta de la función de transferencia.
    output:
          y: respuesta de la función de transferencia.
          t: vector de tiempo de la función de transferencia.

    código:
          #Forzar libreria control
          num,den,gain=InfoTF("num_den",TF)

          numcK=[]
          for i in num:
            numcK.append(float(i)*gain)
          denc=[]
          for i in den:
            denc.append(float(i))
          TF=generarTF("num_den",numcK,denc)
          #Forzar libreria control

          t,y=control.step_response(TF,tiempo)
          ax.plot(t,y)
          return y,t
  '''

  #Forzar libreria control
  num,den,gain=InfoTF("num_den",TF)

  numcK=[]
  for i in num:
    numcK.append(float(i)*gain)
  denc=[]
  for i in den:
    denc.append(float(i))
  TF=generarTF("num_den",numcK,denc)
  #Forzar libreria control

  t,y=control.step_response(TF,tiempo)
  ax.plot(t,y)
  return y,t

def ajustarLimites(limites):
  """
  input:
        limites: formato de entrada en el que pueden faltar algun componente de los cuatro valores [[-x,x],[-y,y]].
  output:
        xmin,xmax,ymin,ymax: devuelve los cuatro valores arreglados
  """
  xmax=0
  xmin=0
  ymax=0
  ymin=0

  #arreglar limites para X
  valuesX=limites[0]
  if len(valuesX)==2:
    xmin = min(valuesX)
    xmax = max(valuesX)
  else:
    if valuesX[0]<0:
      xmin=valuesX[0]
      xmax=-valuesX[0]
    else:
      xmin=-valuesX[0]
      xmax=1
  #arreglar limites para Y
  valuesY=limites[1]
  if len(valuesY)==2:
    ymin = min(valuesY)
    ymax = max(valuesY)
  else:
    if valuesY[0]<0:
      ymin=valuesY[0]
      ymax=-valuesY[0]
    else:
      ymin=-valuesY[0]
      ymax=valuesY[0]
  return xmin,xmax,ymin,ymax

def dibujarEjes(ax,paso,limites):

  """
  input:
        ax: ventana donde se dibujará la imagen.
        paso: unidad minima de la gradilla.
        limites: formato de entrada en el que pueden faltar algun componente de los cuatro valores [[-x,x],[-y,y]].
  output:
        xmin,xmax,ymin,ymax: devuelve los cuatro valores arreglados.
  código:
        xmin,xmax,ymin,ymax=ajustarLimites(limites)

        ax.set(xlim=(xmin-1, xmax+1), ylim=(ymin-1, ymax+1), aspect='equal')
        # Establecemos en 0,0 el origen del eje de coordenadas para representar
        # las marcas de la escala de los ejes
        ax.spines['bottom'].set_position('zero')
        ax.spines['left'].set_position('zero')
        # Borramos las marcas en un lado de la grafica para mejorar el diseño
        ax.spines['top'].set_visible(False)
        ax.spines['right'].set_visible(False)
        # Escribimos el nombre de cada ejes
        ax.set_xlabel('Real', size=14, labelpad=-24, x=1.03)
        ax.set_ylabel('Im', size=14, labelpad=-21, y=1.02, rotation=0)
        # Creamos las marcas principales personalizadas para determinar la posición
        # de las etiquetas de cada marca
        ticks_frequency = paso
        x_ticks = np.arange(xmin, xmax+1, ticks_frequency)
        y_ticks = np.arange(ymin, ymax+1, ticks_frequency)
        ax.set_xticks(x_ticks[x_ticks != 0])
        ax.set_yticks(y_ticks[y_ticks != 0])
        # Creamos las marcas menores colocadas en cada entero para habilitar el dibujo de
        # las líneas de cuadrícula menores: tenga en cuenta que esto no tiene efecto en
        ax.set_xticks(np.arange(xmin, xmax+1), minor=True)
        ax.set_yticks(np.arange(ymin, ymax+1), minor=True)
        # Dibujamos las lineas de la cuadrícula
        ax.grid(which='both', color='grey', linewidth=1, linestyle='-', alpha=0.2)
        # Dibujamos las flechas
        arrow_fmt = dict(markersize=4, color='black', clip_on=False)
        ax.plot((1), (0), marker='>', transform=ax.get_yaxis_transform(), **arrow_fmt)
        ax.plot((0), (1), marker='^', transform=ax.get_xaxis_transform(), **arrow_fmt)
  """

  xmin,xmax,ymin,ymax=ajustarLimites(limites)

  ax.set(xlim=(xmin-1, xmax+1), ylim=(ymin-1, ymax+1), aspect='equal')
  # Establecemos en 0,0 el origen del eje de coordenadas para representar
  # las marcas de la escala de los ejes
  ax.spines['bottom'].set_position('zero')
  ax.spines['left'].set_position('zero')
  # Borramos las marcas en un lado de la grafica para mejorar el diseño
  ax.spines['top'].set_visible(False)
  ax.spines['right'].set_visible(False)
  # Escribimos el nombre de cada ejes
  ax.set_xlabel('Real', size=14, labelpad=-24, x=1.03)
  ax.set_ylabel('Im', size=14, labelpad=-21, y=1.02, rotation=0)
  # Creamos las marcas principales personalizadas para determinar la posición
  # de las etiquetas de cada marca
  ticks_frequency = paso
  x_ticks = np.arange(xmin, xmax+1, ticks_frequency)
  y_ticks = np.arange(ymin, ymax+1, ticks_frequency)
  ax.set_xticks(x_ticks[x_ticks != 0])
  ax.set_yticks(y_ticks[y_ticks != 0])
  # Creamos las marcas menores colocadas en cada entero para habilitar el dibujo de
  # las líneas de cuadrícula menores: tenga en cuenta que esto no tiene efecto en
  ax.set_xticks(np.arange(xmin, xmax+1), minor=True)
  ax.set_yticks(np.arange(ymin, ymax+1), minor=True)
  # Dibujamos las lineas de la cuadrícula
  ax.grid(which='both', color='grey', linewidth=1, linestyle='-', alpha=0.2)
  # Dibujamos las flechas
  arrow_fmt = dict(markersize=4, color='black', clip_on=False)
  ax.plot((1), (0), marker='>', transform=ax.get_yaxis_transform(), **arrow_fmt)
  ax.plot((0), (1), marker='^', transform=ax.get_xaxis_transform(), **arrow_fmt)

def zoom(figOrAx,limites):

  """
  input:
        figOrAx: figura o ejes que se utilizarán como referencia para la copia
        limites: formato de entrada en el que pueden faltar algun componente de los cuatro valores [[-x,x],[-y,y]].
  output:
        cx: devuelve la ventana en la que se ha dibujado
  """

  xmin,xmax,ymin,ymax=ajustarLimites(limites)

  if type(figOrAx)==matplotlib.figure.Figure:
    fig2=copy.deepcopy(figOrAx)
    cx = fig2.get_axes()[0]
  elif type(figOrAx)==matplotlib.axes._axes.Axes:
    cx=copy.deepcopy(figOrAx)

  cx.set_xlim(xmin, xmax)  # Set the x-axis limits
  cx.set_ylim(ymin, ymax)  # Set the y-axis limits
  return cx

def dibujarPolosCeros(ax,limites,TF,tono=1.0):
  #REVISAR EDUARDO#
  """
  input:
        ax: ventana donde se dibujará la imagen.
        limites: formato de entrada en el que pueden faltar algun componente de los cuatro valores [[-x,x],[-y,y]].
        TF: función de transferencia.
  output:

  código:
        ceros,polos,gain=InfoTF("ceros_polos",TF)

        for i in range(len(polos)) :
          ax.scatter(polos[i].real, polos[i].imag, s=200,c='r', marker="x")
        for j in range(len(ceros)) :
          ax.scatter(ceros[j].real, ceros[j].imag, s=200,c='b', marker="o")
  """

  xmin,xmax,ymin,ymax=ajustarLimites(limites)
  ax.set_xlim(xmin, xmax)
  ax.set_ylim(ymin, ymax)

  #Forzar libreria control
  num,den,gain=InfoTF("num_den",TF)

  numcK=[]
  for i in num:
    numcK.append(i*gain)
  denc=[]
  for i in den:
    denc.append(i)
  TF=generarTF("num_den",numcK,denc)
  #Forzar libreria control


  ceros,polos,gain=InfoTF("ceros_polos",TF)

  for i in range(len(polos)) :
    ax.scatter(polos[i].real, polos[i].imag, s=200,color=(tono, 0, 0), marker="x")
  for j in range(len(ceros)) :
    ax.scatter(ceros[j].real, ceros[j].imag, s=200,color=(0, 0, tono), marker="o")

def polosDominantes(TF, polo):
  """
  input:
        TF: función de transferencia.
  output:
        DominanteONoDominante: True o False depenendiendo de si es o no dominante el polo evaluado
  código:
        ceros,polos,gain=InfoTF("ceros_polos",TF)

        # Verificar si hay un cero cercano al polo
        for c in ceros:
            if abs(polo - c) < 0.01:  # Ajusta el valor de tolerancia según sea necesario
                return False

        # Encontrar el polo de baja frecuencia más cercano
        min_low_freq_pole = min(polos, key=lambda p: abs(p - 0j))

        # Verificar si la parte real del polo es al menos 10 veces mayor que la parte real del polo de baja frecuencia más cercano
        if polo.real >= 10 * min_low_freq_pole.real:
            return True

        return False
  """
  ceros,polos,gain=InfoTF("ceros_polos",TF)


  # Encontrar el polo de baja frecuencia más cercano
  min_low_freq_pole = min(polos, key=lambda p: abs(p - 0j))

  print("Polo Dominante: ",min_low_freq_pole)

 # Verificar si hay un cero cercano al polo
  for c in ceros:
      if abs(polo - c) < abs(min_low_freq_pole.real):  # Ajusta el valor de tolerancia según sea necesario
          return False

  # Verificar si la parte real del polo es al menos 10 veces mayor que la parte real del polo de baja frecuencia más cercano
  if abs(polo.real)<=6*abs(min_low_freq_pole.real):
      return True

  return False

def regimenPermanente(G,H,VectorError):
  """
  input:
        TF: función de transferencia.
        VectorError: puede ser errP para el error y constante de posición,  errV para el error y constante de velocidad y errA para el error y constante de acceleración. Se pueden combinar en el vector.
  output:
        VectorErrorReturn: vector que contiene tuplas de los errores de posición, velocidad y acceleración.

        [kp: constante del error de posición , ep: error de posición en régimen permanente]
        [kv: constante del error de velocidad , ev: error de velocidad en régimen permanente]
        [ka: constante del derror de acceleración ,ea: error de acceleración en régimen permanente]

  código:
        s = sympy.Symbol('s')

        #Forzar libreria sympy
        num,den,gain=InfoTF("num_den",G)
        numcK=[]
        for i in num:
          numcK.append(float(i)*gain)
        num=generarTF("num_den",numcK,[1],1)
        den=generarTF("num_den",den,[1],1)
        G=num/den
        #Forzar libreria sympy

        #Forzar libreria sympy
        num,den,gain=InfoTF("num_den",H)
        numcK=[]
        for i in num:
          numcK.append(float(i)*gain)
        num=generarTF("num_den",numcK,[1],1)
        den=generarTF("num_den",den,[1],1)
        H=num/den
        #Forzar libreria sympy

        Mp=G*H
        Mv=s*G*H
        Ma=s*s*G*H

        VectorErrorReturn=[]

        kp=Mp.subs(s, 0),
        ep=1/(1+Mp.subs(s, 0))
        if VectorError.count("errP") > 0:
          VectorErrorReturn.append([kp,ep])

        kv=Mv.subs(s, 0),
        ev=1/(Mv.subs(s, 0))
        if VectorError.count("errV") > 0:
          VectorErrorReturn.append([kv,ev])

        ka=Ma.subs(s, 0)
        ea=1/(Ma.subs(s, 0))
        if VectorError.count("errA") > 0:
          VectorErrorReturn.append([ka,ea])

        return  VectorErrorReturn
  """
  s = sympy.Symbol('s')

  #Forzar libreria sympy
  num,den,gain=InfoTF("num_den",G)
  numcK=[]
  for i in num:
    numcK.append(float(i)*gain)
  num=generarTF("num_den",numcK,[1],1)
  den=generarTF("num_den",den,[1],1)
  G=num/den
  #Forzar libreria sympy

  #Forzar libreria sympy
  num,den,gain=InfoTF("num_den",H)
  numcK=[]
  for i in num:
    numcK.append(float(i)*gain)
  num=generarTF("num_den",numcK,[1],1)
  den=generarTF("num_den",den,[1],1)
  H=num/den
  #Forzar libreria sympy

  Mp=G*H
  Mv=s*G*H
  Ma=s*s*G*H

  VectorErrorReturn=[]

  kp=Mp.subs(s, 0),
  ep=100*(1/(1+Mp.subs(s, 0)))
  if VectorError.count("errP") > 0:
    VectorErrorReturn.append([kp,ep])

  kv=Mv.subs(s, 0),
  ev=100*(1/(Mv.subs(s, 0)))
  if VectorError.count("errV") > 0:
    VectorErrorReturn.append([kv,ev])

  ka=Ma.subs(s, 0)
  ea=1/(Ma.subs(s, 0))
  if VectorError.count("errA") > 0:
    VectorErrorReturn.append([ka,ea])

  return  VectorErrorReturn

def errCriterio(err,errPunto):
  """
  input:
        err: en porcentaje, restricción de error del sistema
        errPunto: en porcentaje, error del sistema para cierto punto
  output:
        True or False, si cumple o no
  código:
        if errp>errPunto:
          print("Cumple el criterio de regimen permanente")
          return True
        else
          print("No cumple el criterio de regimen permanente")
          return False
  """

  if err>errPunto:
    print("Cumple el criterio de regimen permanente")
    return True
  else:
    print("No cumple el criterio de regimen permanente")
    return False

def tipoRespuesta2orden(TF):

  """
  input:
        TF: función de transferencia.
  output:
        tipo: tipo del sistema de segundo orden.
            inestable=-1
            subamortiguado=0
            amortiguado=1
            sobreamortiguado=2
  código:
        ceros,polos,gain=InfoTF("ceros_polos",TF)
        if (polos[0].real and polos[1].real)==0:
          print('Sistema de 2do orden inestable')
          tipo=-1
        elif (polos[0].real == polos[1].real):
          print('Sistema de 2do orden subamortiguado')
          tipo=0
        elif polos[0]==polos[1]:
          print('Sistema de 2do orden críticamente amortiguado')
          tipo=1
        else:
          print('Sistema de 2do orden sobreamortiguado')
          tipo=2
        return tipo
  """

  ceros,polos,gain=InfoTF("ceros_polos",TF)

  if (polos[0].real and polos[1].real)==0:
    print('Sistema de 2do orden inestable')
    tipo=-1
  elif (polos[0].real == polos[1].real):
    print('Sistema de 2do orden subamortiguado')
    tipo=0
  elif polos[0]==polos[1]:
    print('Sistema de 2do orden críticamente amortiguado')
    tipo=1
  else:
    print('Sistema de 2do orden sobreamortiguado')
    tipo=2
  return tipo

def parameterMp(Mp):

  """
  input:
        Mp: especificación de las restricciones del sistema, sobreoscilación.
  output:
        theta: devuelve el valor que limita la zona valida, según las restricciones.

  código:
        if Mp!=None:
            Mp=Mp/100
            theta=np.arctan(-math.pi/np.log(Mp))
        return theta
  """

  if Mp!=None:
    Mp=Mp/100
    theta=np.arctan(-math.pi/np.log(Mp))
  return theta

def parameterTp(Tp):

  """
  input:
        Tp: especificación de las restricciones del sistema, tiempo de pico.
  output:
        wd: devuelve el valor que limita la zona valida, según las restricciones.

  código:
        if Tp!=None:
          wd=math.pi/Tp
        return wd
  """

  if Tp!=None:
    wd=math.pi/Tp
  return wd

def parameterTs(Ts):

  """
  input:
        Ts: especificación de las restricciones del sistema, tiempo de pico.
  output:
        sgm: devuelve el valor que limita la zona valida, según las restricciones.

  código:
        if Ts!=None:
          sgm=math.pi/Ts
        return sgm
  """

  if Ts!=None:
    sgm=math.pi/Ts
  return sgm

def dibujarRestriccionMp(ax,theta,limites):

  """
  input:
        ax: ventana donde se dibujará la imagen.
        theta: limite para las restricciones.
        limites: formato de entrada en el que pueden faltar algun componente de los cuatro valores [[-x,x],[-y,y]].
  output:
        x1: componente de los puntos X en los que se encuentran los limites de las restricciones.
        y1: componente de los puntos Y en los que se encuentran los limites de las restricciones.

  código:
        xmin,xmax,ymin,ymax=ajustarLimites(limites)

        if theta!=None:
          x1 = [-xmax * math.cos(theta), 0,0, -xmax * math.cos(theta)]
          y1 = [-ymax * math.sin(theta), 0,0,  ymax * math.sin(theta)]
        else:
          x1 = [-xmax,0,0,-xmax]
          y1 = [ymax,ymax,-ymax,-ymax]
        if ax!=None:
          ax.plot(x1, y1, c='brown', ls='--', lw=1, alpha=1)
          ax.fill(x1, y1, alpha=0.2, color='r', hatch='/')

        return x1,y1
  """

  xmin,xmax,ymin,ymax=ajustarLimites(limites)

  xmin=10000*xmin
  xmax=10000*xmax
  ymin=10000*ymin
  ymax=10000*ymax

  if theta!=None:
    x1 = [-xmax * math.cos(theta), 0,0, -xmax * math.cos(theta)]
    y1 = [-ymax * math.sin(theta), 0,0,  ymax * math.sin(theta)]
  else:
    x1 = [-xmax,0,0,-xmax]
    y1 = [ymax,ymax,-ymax,-ymax]
  if ax!=None:
    ax.plot(x1, y1, c='brown', ls='--', lw=1, alpha=1)
    ax.fill(x1, y1, alpha=0.2, color='r', hatch='/')

  return x1,y1

def dibujarRestriccionTp(ax,wd,limites):

  """
  input:
        ax: ventana donde se dibujará la imagen.
        wd: limite para las restricciones.
        limites: formato de entrada en el que pueden faltar algun componente de los cuatro valores [[-x,x],[-y,y]].
  output:
        x21: componente de los puntos X en los que se encuentran los limites de las restricciones en Y+.
        y21: componente de los puntos Y en los que se encuentran los limites de las restricciones en Y+.
        x22: componente de los puntos X en los que se encuentran los limites de las restricciones en Y-.
        y22: componente de los puntos Y en los que se encuentran los limites de las restricciones en Y-.

  código:
        xmin,xmax,ymin,ymax=ajustarLimites(limites)

        if wd!=None:
          x21 = [0, 0, -xmax, -xmax]
          y21 = [ymax, wd, wd, ymax]
          x22 = [0, 0, -xmax, -xmax]
          y22 = [-ymax, -wd, -wd, -ymax]
        else:
          x21 = [-xmax,0,0,-xmax]
          y21 = [ymax,ymax,-ymax,-ymax]
          x22 = [-xmax,0,0,-xmax]
          y22 = [-ymax,-ymax,-ymax,-ymax]

        if ax!=None:
          ax.fill(x21,y21,alpha=0.3,color='green',hatch='|')
          ax.fill(x22,y22,alpha=0.3,color='green',hatch='|')
        return x21,y21,x22,y22
  """

  xmin,xmax,ymin,ymax=ajustarLimites(limites)

  xmin=10000*xmin
  xmax=10000*xmax
  ymin=10000*ymin
  ymax=10000*ymax

  if wd!=None:
    x21 = [0, 0, -xmax, -xmax]
    y21 = [ymax, wd, wd, ymax]
    x22 = [0, 0, -xmax, -xmax]
    y22 = [-ymax, -wd, -wd, -ymax]
  else:
    x21 = [-xmax,0,0,-xmax]
    y21 = [ymax,ymax,-ymax,-ymax]
    x22 = [-xmax,0,0,-xmax]
    y22 = [-ymax,-ymax,-ymax,-ymax]

  if ax!=None:
    ax.fill(x21,y21,alpha=0.3,color='green',hatch='|')
    ax.fill(x22,y22,alpha=0.3,color='green',hatch='|')
  return x21,y21,x22,y22

def dibujarRestriccionTs(ax,sigma,limites):

  """
  input:
        ax: ventana donde se dibujará la imagen.
        sigma: limite para las restricciones.
        limites: formato de entrada en el que pueden faltar algun componente de los cuatro valores [[-x,x],[-y,y]].
  output:
        x3: componente de los puntos X en los que se encuentran los limites de las restricciones.
        y3: componente de los puntos Y en los que se encuentran los limites de las restricciones.

  código:
        xmin,xmax,ymin,ymax=ajustarLimites(limites)

        if sigma!=None:
          x3= [-xmax,-sigma,-sigma,-xmax]
          y3= [ymax,ymax,-ymax,-ymax]
        else:
          x3= [-xmax,0,0,-xmax]
          y3= [ymax,ymax,-ymax,-ymax]
        if ax!=None:
          ax.fill(x3,y3,alpha=0.3,color='orange',hatch='|')
        return x3,y3
  """

  xmin,xmax,ymin,ymax=ajustarLimites(limites)

  xmin=10000*xmin
  xmax=10000*xmax
  ymin=10000*ymin
  ymax=10000*ymax

  if sigma!=None:
    x3= [-xmax,-sigma,-sigma,-xmax]
    y3= [ymax,ymax,-ymax,-ymax]
  else:
    x3= [-xmax,0,0,-xmax]
    y3= [ymax,ymax,-ymax,-ymax]
  if ax!=None:
    ax.fill(x3,y3,alpha=0.3,color='orange',hatch='|')
  return x3,y3

def parametrosRespuestaTemporal(ax,valores,tiempo):

  """
  input:
        ax: ventana donde se dibujará la imagen.
        valores: valor de puesta temporal en el eje Y del sistema de transferencia.
        tiempo: vector temporal de la respuesta temporal en el eje X del sistema de transferencia.
  output:

  código:
        t=tiempo
        y=valores

        b=y[len(t)-1]
        a=max(y)-b
        errp=1-y[len(t)-1]


        ax.plot([0, 0], [0, y[len(t)-1]], c='green', ls='--', lw=1, alpha=1)
        ax.annotate('b=%s'%round(b,3),(0,b/2),(0,b/2))
        ax.plot([0, 0], [y[len(t)-1], max(y)], c='blue', ls='--', lw=1, alpha=1)
        ax.annotate('a=%s'%round(a,3),(0,b+a/2),(0,b+a/2))
        ax.annotate('a+b=%s'%round(a+b,3),(0,b+a),(0,b+a))
        ax.annotate('vf=%s'%round(b,3),(t[len(t)-1],b),(t[len(t)-1],b))

        print("Sobreoscilacion: ",100*(a/b),"%")
        print("Errp: ",errp)
        print("b: ",b)
        print("a: ",a)
        print("valor final: ",b)
        print("max: ",a+b)
        if a>0:

          tp=t[np.argmax(y)]
          print("tp: ",tp,"s")
          ax.annotate('tp=%s s'%round(tp,3),(tp,0.1),(tp,0.1))
          ax.plot([0, tp], [y[len(t)-1], y[len(t)-1]], c='red', ls='--', lw=1, alpha=1)
          ax.plot([0, tp], [a+b, a+b], c='b', ls='--', lw=1, alpha=1)
          ax.plot([tp, tp], [0, y[np.argmax(y)]], c='red', ls='--', lw=1, alpha=1)
          ax.plot([tp, t[len(t)-1]], [y[len(t)-1], y[len(t)-1]], c='black', ls='--', lw=1, alpha=1)
        else:
          pto_y=0.632*np.max(y)
          round_pto_y=round(pto_y,5)
          round_K=round(np.max(y),5)
          for i in range(len(y)):
            if pto_y-y[i]<0:
              ts=t[i-1]
              break
          ax.annotate('T=%s s'%round(ts,3),(ts,pto_y-0.1),(ts,pto_y-0.1))
  """

  t=tiempo
  y=valores

  b=y[len(t)-1]
  a=max(y)-b
  errp=1-y[len(t)-1]

  ax.set(xlim=(-6.5, t[len(t)-1]+0.2), ylim=(-0.2, max(y)+0.2))

  ax.plot([0, 0], [0, y[len(t)-1]], c='green', ls='--', lw=1, alpha=1)
  ax.annotate('b=%s'%round(b,3),(0,b/2),(0,b/2))
  ax.annotate('vf=%s'%round(b,3),(t[len(t)-1],b),(t[len(t)-1],b))


  print("Errp: ",errp)
  print("valor final: ",b)


  if a>0:
    ax.plot([0, 0], [y[len(t)-1], max(y)], c='blue', ls='--', lw=1, alpha=1)
    ax.annotate('a=%s'%round(a,3),(0,b+a/2),(0,b+a/2))
    ax.annotate('a+b=%s'%round(a+b,3),(-6,(b+a)/2),(-6,(b+a)/2))
    ax.annotate('Mp=%s%%'%round((a/b)*100),(-6,((b+a)/2)-0.3),(-6,((b+a)/2)-0.3))

    print("Sobreoscilacion: ",100*(a/b),"%")
    print("b: ",b)
    print("a: ",a)
    print("Mp: ",(a/b)*100)
    print("max: ",a+b)

    tp=t[np.argmax(y)]
    print("tp: ",tp,"s")

    tr=[]
    ytr=[]
    vfind=t[np.argmax(y)]
    for i in range(len(y)):
      if vfind-y[i]<0.1:
        tr=t[i-1]
        ytr=y[i]
        break
    print("tr: ",tr,"s")

    ax.annotate('tp=%s s'%round(tp,3),(tp,0.1),(tp,0.1))
    ax.annotate('tr=%s s'%round(tr,3),(tr,0.1),(tr,0.1))
    ax.plot([0, tr], [ytr, ytr], c='green', ls='--', lw=1, alpha=1)
    ax.plot([0, tp], [y[len(t)-1], y[len(t)-1]], c='red', ls='--', lw=1, alpha=1)
    ax.plot([0, tp], [a+b, a+b], c='b', ls='--', lw=1, alpha=1)
    ax.plot([tp, tp], [0, y[np.argmax(y)]], c='green', ls='--', lw=1, alpha=1)
    ax.plot([tp, t[len(t)-1]], [y[len(t)-1], y[len(t)-1]], c='black', ls='--', lw=1, alpha=1)
  elif (y[1] - y[0]) / (t[1] - t[0])>0.2:

    pto_y=0.632*np.max(y)
    round_pto_y=round(pto_y,5)
    round_K=round(np.max(y),5)
    for i in range(len(y)):
      if pto_y-y[i]<0.1:
        T=t[i-1]
        break
    ax.plot([0, T], [0, np.max(y)], c='y', ls='--', lw=1, alpha=1)
    ax.annotate('/=%s'%round(np.max(y)/T,3),(-5,np.max(y)/2),(-5,np.max(y)/2))
    ax.plot([0, T], [pto_y, pto_y], c='r', ls='--', lw=1, alpha=1)
    ax.plot([T, T], [0, pto_y], c='g', ls='--', lw=1, alpha=1)
    ax.annotate('T=%s s'%round(T,3),(T,pto_y-0.1),(T,pto_y-0.1))

def parametrosTipoRegimen(ax,y,t):


  """
  input:
        y: valores de la señal para la respuesta en regimen permanente
        t: vector de tiempos correspondiente a los valores de la señal en regimen permanente
  output:

  código:
        fv=y[len(t)-1]

        max5fv=fv+fv*(5/100)
        min5fv=fv-fv*(5/100)

        rp=[]
        yp=[]
        pto_y=max5fv
        for i in range(len(y)):
          if pto_y-y[i]<0:
            rp=t[i-1]
            yp=pto_y
            break
        if rp!=None:
          pto_y=min5fv
          for i in range(len(y)):
            if pto_y-y[i]<0:
              rp=t[i-1]
              yp=pto_y
              break

        ax.plot([rp, rp], [0, yp], c='green', ls='--', lw=1, alpha=1)
        ax.plot([0, rp], [yp, yp], c='red', ls='--', lw=1, alpha=1)
        ax.plot([rp, len(t)], [yp, yp], c='blue', ls='--', lw=1, alpha=1)
        ax.annotate('Régimen \n transitorio',(rp/2,yp-0.1),(rp/2,yp-0.1))
        ax.annotate('Régimen \n permanente',(t[len(t)-1]/2,yp-0.1),(t[len(t)-1]/2,yp-0.1))
  """

  fv=y[len(t)-1]

  max5fv=fv+fv*(5/100)
  min5fv=fv-fv*(5/100)

  rp=[]
  yp=[]
  pto_y=max5fv
  for i in range(len(y)):
    if pto_y-y[i]<0.1:
      rp=t[i-1]
      yp=pto_y
      break
  if rp!=None:
    pto_y=min5fv
    for i in range(len(y)):
      if pto_y-y[i]<0.1:
        rp=t[i-1]
        yp=pto_y
        break

  ax.plot([rp, rp], [0, yp], c='green', ls='--', lw=1, alpha=1)
  ax.annotate('Ts=%s s'%round(rp,3),(rp,0.1),(rp,0.1))
  ax.plot([0, rp], [yp, yp], c='red', ls='--', lw=1, alpha=1)
  ax.plot([rp, t[len(t)-1]], [yp, yp], c='blue', ls='--', lw=1, alpha=1)
  ax.annotate('Régimen \n transitorio',(rp/2,yp-0.1),(rp/2,yp-0.1))
  ax.annotate('Régimen \n permanente',(t[len(t)-1]/2,yp-0.1),(t[len(t)-1]/2,yp-0.1))